local Players = game:GetService("Players")
local player = Players.LocalPlayer
local RepStore = game:GetService("ReplicatedStorage")

-- Remotes
local RemoteEvents = RepStore:WaitForChild("RemoteEvents")
local RemoteFunctions = RepStore:WaitForChild("RemoteFunctions")
local SelectIndustry = RemoteEvents:WaitForChild("SelectNewIndusty")
local ApplyNewSetting = RemoteFunctions:WaitForChild("ApplyNewSetting")
local UpdateIndustries = RemoteEvents:WaitForChild("UpdateIndustries")

-- ===================== NUMBER PARSER =====================
local SUFFIX_MULTIPLIERS = {
    K  = 1e3,
    M  = 1e6,
    B  = 1e9,
    T  = 1e12,
    Q  = 1e15,
    Qn = 1e18,
    S  = 1e21,
    Sp = 1e24,
    Oc = 1e27,
}

local function parseAbbreviatedNumber(text)
    if not text then return nil end
    local clean = tostring(text):gsub(",", ""):gsub("%s+", ""):gsub("[%$]", "")

    for suffix, mult in pairs(SUFFIX_MULTIPLIERS) do
        if clean:sub(-#suffix) == suffix then
            local numberPart = clean:sub(1, -#suffix-1)
            local num = tonumber(numberPart)
            if num then
                return num * mult
            end
        end
    end

    return tonumber(clean) or nil
end

-- ===================== UTIL =====================
local function getRoot()
    local char = player.Character or player.CharacterAdded:Wait()
    return char:WaitForChild("HumanoidRootPart")
end

local function getMoneyRaw()
    local stats = player:FindFirstChild("leaderstats")
    if not stats then return 0 end
    local money = stats:FindFirstChild("Money")
    if not money then return 0 end
    return parseAbbreviatedNumber(money.Value) or 0
end

local function getClosestTycoon()
    local root = getRoot()
    local closest = nil
    local minDist = math.huge

    for _, tycoonBase in ipairs(game.Workspace.TycoonLocations:GetChildren()) do
        if tycoonBase:IsA("BasePart") then
            local dist = (tycoonBase.Position - root.Position).Magnitude
            if dist < minDist then
                minDist = dist
                closest = tycoonBase
            end
        end
    end

    return closest
end

-- ===================== INDUSTRY LOGIC =====================
-- ===================== INDUSTRY LOGIC (SAFEGUARDED) =====================
local industryLevels = {}
local managerActive = false
local lastSelectedIndustry = nil

UpdateIndustries.OnClientEvent:Connect(function(data)
    industryLevels = data
end)

local function updateIndustryManager()
    local bestName = nil
    local bestValue = -math.huge
    local hasAbove100 = false

    for name, value in pairs(industryLevels) do
        if value >= 1 then
            hasAbove100 = true
        end
        if value > bestValue then
            bestValue = value
            bestName = name
        end
    end

    -- === TURN OFF MANAGER ===
    if not hasAbove100 then
        if managerActive then
            ApplyNewSetting:InvokeServer("UseManager", 0)
            print("[DEBUG] Manager OFF (all industries < 100%)")
            managerActive = false
            lastSelectedIndustry = nil
        end
        return
    end

    -- === TURN ON MANAGER ===
    if not managerActive then
        ApplyNewSetting:InvokeServer("UseManager", 1)
        print("[DEBUG] Manager ON")
        managerActive = true
    end

    -- === SELECT BEST INDUSTRY (ONLY IF CHANGED) ===
    if bestName and bestName ~= lastSelectedIndustry then
        SelectIndustry:FireServer(bestName)
        print("[DEBUG] Switching industry to:", bestName, "Efficiency:", bestValue)
        lastSelectedIndustry = bestName
    end
end

-- ===================== INITIALIZE =====================
local closestTycoon = getClosestTycoon()
if not closestTycoon then
    warn("No tycoon found!")
    return
end

local tycoonName = tostring(closestTycoon.Name)
local tycoonFolder = game.Workspace.Tycoons:FindFirstChild(tycoonName)
if not tycoonFolder then
    warn("Tycoon folder not found: " .. tycoonName)
    return
end

local tycoonButtonsFolder = tycoonFolder:FindFirstChild("PurchaseableModels")
if not tycoonButtonsFolder then
    warn("PurchaseableModels not found in tycoon: " .. tycoonName)
    return
end

-- ===================== MAIN LOOP =====================
while task.wait(0.5) do
    -- === TELEPORT TO BUTTON LOGIC ===
    local lowestPrice = math.huge
    local cheapestButton = nil
    local cheapestPrice = nil
    local freeButton = nil

    for _, model in ipairs(tycoonButtonsFolder:GetChildren()) do
        local buttonModel = model:FindFirstChild("Button")
        if not buttonModel then continue end

        local priceLabel = buttonModel:FindFirstChild("Price", true)
        if not priceLabel or not priceLabel:IsA("TextLabel") then continue end

        local priceText = priceLabel.Text
        if priceText:find("Tokens") then continue end

        -- Find the physical BasePart button
        local physicalButton = nil
        for _, obj in ipairs(buttonModel:GetDescendants()) do
            if obj.Name == "Button" and obj:IsA("BasePart") then
                physicalButton = obj
                break
            end
        end
        if not physicalButton then continue end

        -- FREE buttons override everything
        if priceText:find("FREE%(PREBOUGHT%)") then
            freeButton = physicalButton
            print("[DEBUG] FREE button found:", physicalButton:GetFullName())
            continue
        end

        -- Paid buttons
        local price = parseAbbreviatedNumber(priceText)
        if price then
            if price < lowestPrice then
                lowestPrice = price
                cheapestButton = physicalButton
                cheapestPrice = price
            end
        end
    end

    local targetButton = freeButton or cheapestButton
    local targetPrice  = freeButton and 0 or cheapestPrice

    if targetButton then
        local playerMoney = getMoneyRaw()
        if playerMoney >= (targetPrice or 0) then
            getRoot().CFrame = targetButton.CFrame + Vector3.new(0, 3, 0)
            print("[DEBUG] Teleporting to:", targetButton:GetFullName())
        else
            print("[DEBUG] Not enough money to teleport. PlayerMoney:", playerMoney, "Price:", targetPrice)
        end
    end

    -- === INDUSTRY MANAGER LOGIC ===
    updateIndustryManager()
end
