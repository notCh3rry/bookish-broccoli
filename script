print("v17")

spawn(function()
	loadstring(game:HttpGet("https://pastebin.com/raw/6ngxJT8b"))() --freecam lshift+p
	loadstring(game:HttpGet('https://raw.githubusercontent.com/Lucasfin000/SpaceHub/main/UESP'))() --esp
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Player = Players.LocalPlayer

local isOpen = false
local PlayerDetectionOn = true
local AutoOresOn = false
local CollectOn = false
local CoordMinerOn = false
local platform

local MoveAllItems = ReplicatedStorage:WaitForChild("MoveAllItems")
local BlocksToReset = 115000
local SafetyDistance = 200
local CollectThreshold = 500

local coordMinerState = {
	currentX = nil,
	currentY = nil,
	currentZ = nil,
	targetX = nil,
	targetY = nil,
	targetZ = nil,
	active = false
}

game.Workspace:WaitForChild("Players"):WaitForChild("Chryslixm"):WaitForChild("AnomalyRunner"):Destroy()

local function getCharacter()
	-- Wait for character respawn if it's gone
	if not Player.Character then
		Player.CharacterAdded:Wait()
	end

	-- Wait for HRP in the new character
	local char = Player.Character
	local hrp = char:WaitForChild("HumanoidRootPart", 10) -- 10 sec timeout
	return char, hrp
end

-- UI Setup (same as before)
local ScreenGui = Instance.new("ScreenGui", Player:WaitForChild("PlayerGui"))
ScreenGui.Name = "Ooga"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainFrame = Instance.new("Frame", ScreenGui)
MainFrame.Size = UDim2.new(0.157, 0, 0.731, 0)
MainFrame.Position = UDim2.new(0.132, 0, 0.125, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false

local AspectRatio = Instance.new("UIAspectRatioConstraint", MainFrame)
AspectRatio.AspectRatio = 0.316
AspectRatio.AspectType = Enum.AspectType.FitWithinMaxSize
AspectRatio.DominantAxis = Enum.DominantAxis.Width

local OreInput = Instance.new("TextBox", MainFrame)
OreInput.Size = UDim2.new(0.927, 0, 0.163, 0)
OreInput.Position = UDim2.new(0.037, 0, 0.188, 0)
OreInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OreInput.BorderSizePixel = 0
OreInput.Font = Enum.Font.Highway
OreInput.TextScaled = true
OreInput.PlaceholderText = "Ore to Find"
OreInput.Text = ""
OreInput.ClearTextOnFocus = false
OreInput.TextColor3 = Color3.fromRGB(255, 255, 255)

local CoordMinerInput = Instance.new("TextBox", MainFrame)
CoordMinerInput.Size = UDim2.new(0.689, 0, 0.034, 0)
CoordMinerInput.Position = UDim2.new(0.037, 0, 0.143, 0)
CoordMinerInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerInput.BorderSizePixel = 0
CoordMinerInput.Font = Enum.Font.Highway
CoordMinerInput.TextScaled = true
CoordMinerInput.PlaceholderText = "Coords Goal"
CoordMinerInput.Text = ""
CoordMinerInput.ClearTextOnFocus = false
CoordMinerInput.TextColor3 = Color3.fromRGB(255, 255, 255)

-- Player Detection Toggle Button
local PlayerDetectButton = Instance.new("TextButton", MainFrame)
PlayerDetectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDetectButton.Position = UDim2.new(0.032, 0, 0.057, 0)
PlayerDetectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDetectButton.BorderSizePixel = 0
PlayerDetectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerDetectButton.TextScaled = true
PlayerDetectButton.Font = Enum.Font.Highway
PlayerDetectButton.Text = "Player Detection: ON"
PlayerDetectButton.Activated:Connect(function()
	PlayerDetectionOn = not PlayerDetectionOn
	if PlayerDetectionOn then
		PlayerDetectButton.Text = "Player Detection: ON"
	else
		PlayerDetectButton.Text = "Player Detection: OFF"
	end
end)

-- TP Button
local AutoOresButton = Instance.new("TextButton", MainFrame)
AutoOresButton.Size = UDim2.new(0.927, 0, 0.033, 0)
AutoOresButton.Position = UDim2.new(0.037, 0, 0.013, 0)
AutoOresButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
AutoOresButton.BorderSizePixel = 0
AutoOresButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AutoOresButton.TextScaled = true
AutoOresButton.Font = Enum.Font.Highway
AutoOresButton.Text = "Auto Ores: OFF"
AutoOresButton.Activated:Connect(function()
	AutoOresOn = not AutoOresOn
	if AutoOresOn then
		AutoOresButton.Text = "Auto Ores: ON"
	else
		AutoOresButton.Text = "Auto Ores: OFF"
		Player.Character.HumanoidRootPart.Anchored = false
		
		local char, hrp = getCharacter()
		if not char or not hrp then return end
		
		local tool = char:FindFirstChild("Pickaxe") or Player.Backpack:FindFirstChild("Pickaxe")
		if not tool then return end

		if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = true end
	end
end)

local CollectButton = Instance.new("TextButton", MainFrame)
CollectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
CollectButton.Position = UDim2.new(0.032, 0, 0.1, 0)
CollectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CollectButton.BorderSizePixel = 0
CollectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CollectButton.TextScaled = true
CollectButton.Font = Enum.Font.Highway
CollectButton.Text = "Collect Coins: OFF"
CollectButton.Activated:Connect(function()
	CollectOn = not CollectOn
	if CollectOn then
		CollectButton.Text = "Collect Coins: ON"
	else
		CollectButton.Text = "Collect Coins: OFF"
	end
end)

local CoordMinerButton = Instance.new("TextButton", MainFrame)
CoordMinerButton.Size = UDim2.new(0.197, 0, 0.033, 0)
CoordMinerButton.Position = UDim2.new(0.762, 0, 0.144, 0)
CoordMinerButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerButton.BorderSizePixel = 0
CoordMinerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordMinerButton.TextScaled = true
CoordMinerButton.Font = Enum.Font.Highway
CoordMinerButton.Text = "OFF"
CoordMinerButton.Activated:Connect(function()
	CoordMinerOn = not CoordMinerOn
	if CoordMinerOn then
		CoordMinerButton.Text = "ON"
		CoordMinerInput.TextEditable = false
	else
		CoordMinerButton.Text = "OFF"
		CoordMinerInput.TextEditable = true
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end

		coordMinerState = {
			currentX = nil,
			currentY = nil,
			currentZ = nil,
			targetX = nil,
			targetY = nil,
			targetZ = nil,
			active = false
		}
	end
end)

local ToggleButton = Instance.new("TextButton", ScreenGui)
ToggleButton.Size = UDim2.new(0, 53, 0, 51)
ToggleButton.Position = UDim2.new(-0.0007, 0, 0.6601, 0)
ToggleButton.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
ToggleButton.BorderSizePixel = 0
ToggleButton.Text = ""
ToggleButton.Activated:Connect(function()
	MainFrame.Visible = not MainFrame.Visible
end)

local OresLabel = Instance.new("TextLabel", MainFrame)
OresLabel.Size = UDim2.new(0.927, 0, 0.354, 0)
OresLabel.Position = UDim2.new(0.037, 0, 0.363, 0)
OresLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OresLabel.BorderSizePixel = 0
OresLabel.Text = ""
OresLabel.TextScaled = true
OresLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
OresLabel.Font = Enum.Font.Highway

local BlocksInMineLabel = Instance.new("TextLabel", MainFrame)
BlocksInMineLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
BlocksInMineLabel.Position = UDim2.new(0.037, 0, 0.729, 0)
BlocksInMineLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
BlocksInMineLabel.BorderSizePixel = 0
BlocksInMineLabel.Text = "Blocks Until Reset: N/A"
BlocksInMineLabel.TextScaled = true
BlocksInMineLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
BlocksInMineLabel.Font = Enum.Font.Highway

local CoordinatesLabel = Instance.new("TextLabel", MainFrame)
CoordinatesLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
CoordinatesLabel.Position = UDim2.new(0.037, 0, 0.772, 0)
CoordinatesLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordinatesLabel.BorderSizePixel = 0
CoordinatesLabel.Text = ""
CoordinatesLabel.TextScaled = true
CoordinatesLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordinatesLabel.Font = Enum.Font.Highway

local PlayerDistanceLabel = Instance.new("TextLabel", MainFrame)
PlayerDistanceLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDistanceLabel.Position = UDim2.new(0.037, 0, 0.816, 0)
PlayerDistanceLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDistanceLabel.BorderSizePixel = 0
PlayerDistanceLabel.Text = ""
PlayerDistanceLabel.TextScaled = true
PlayerDistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerDistanceLabel.Font = Enum.Font.Highway

-- Coordinates calculation (death safe)
local function getBlockCoordinates(position)
	local x = math.floor(position.X / 6)
	local z = math.floor(position.Z / 6)
	local depth = math.floor((5000 - position.Y) / 6)
	if depth < 0 then depth = 0 end
	return x, depth, z
end

local function safeTeleportToObj(obj)
	local char, hrp = getCharacter()
	if not hrp or not char or not obj or not obj.Parent then return end

	local platformPos = obj.Position - Vector3.new(0, 3, 0)

	if platform and platform.Parent then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "TPPlatform"
	platform.Size = Vector3.new(4, 1, 4)
	platform.CFrame = CFrame.new(platformPos)
	platform.Anchored = true
	platform.CanCollide = true
	platform.Transparency = 1
	platform.Parent = workspace

	-- Teleport player
	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	if char:FindFirstChild("Torso") then char.Torso.CanCollide = false end
	if char:FindFirstChild("Head") then char.Head.CanCollide = false end
	hrp.Anchored = false

	hrp.CFrame = CFrame.new(platformPos + Vector3.new(0, 2, 0))
	task.wait(0.2)

	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	hrp.Anchored = true
end

local function tpBack()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			safeTeleportToObj(v.Spawn)
		end
	end
end

local function equipPickaxeForOre(ore)
	local forge = game.ReplicatedStorage:WaitForChild("Forge")
	local pickaxeName

	if ore.Name == "Dragonstone" or ore.Name == "Boomite" then
		pickaxeName = "Dragonstone" -- Dragonglass pickaxe
	else
		pickaxeName = "Amethyst" -- Default pickaxe
	end

	pcall(function()
		forge:InvokeServer(pickaxeName)
	end)

	local char, hrp = getCharacter()
	
	if not char or not hrp then
		return nil
	end

	local tool = char:FindFirstChild("Pickaxe")
	if not tool then
		repeat
			task.wait()
			tool = char:FindFirstChild("Pickaxe")
		until tool ~= nil or not char or not hrp
	end

	return tool
end


-- Auto-equip Pickaxe on spawn
local function equipPickaxe(char)
	task.spawn(function()
		local backpack = Player:WaitForChild("Backpack")
		local humanoid = char:WaitForChild("Humanoid")
		while humanoid and humanoid.Parent do
			local tool = backpack:FindFirstChild("Pickaxe")
			if tool and not char:FindFirstChild("Pickaxe") then
				humanoid:EquipTool(tool)
			end
			task.wait(1)
		end
	end)
end

if Player.Character then equipPickaxe(Player.Character) end
Player.CharacterAdded:Connect(equipPickaxe)

-- Inventory cleanup
local function checkInventory()
	local ok, err = pcall(function()
		local label = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("Inventory"):WaitForChild("Amount")
		if label and label:IsA("TextLabel") then
			local text = label.Text:gsub("%s+", ""):gsub(",", "")
			local current, max = text:match("^(%d+)/(%d+)$")
			current, max = tonumber(current), tonumber(max)
			if current and max and current >= max then
				MoveAllItems:InvokeServer()
			end
		end
	end)
	if not ok then warn("Empty Inventory Failed: ", err) end
end

local function checkPlayerDistance(object)
	local closestDistance = 999999
	for _, plr in pairs(Players:GetChildren()) do
		if plr ~= Player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			if (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude < closestDistance then
				closestDistance = (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude
			end
		end
	end
	return math.round(closestDistance)
end

-- Wait for ore mined (safe)
local function waitForOreMined(ore)
	if not ore then return end
	local mined = false

	local conn
	conn = ore.AncestryChanged:Connect(function(_, parent)
		if not parent then mined = true conn:Disconnect() end
	end)

	local progressBar
	local selectedOreBox
	pcall(function()
		progressBar = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedItem"):WaitForChild("ProgressBar")
		selectedOreBox = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedOre")
	end)

	local startCheck = tick()
	while progressBar.Visible == false do
		task.wait(0.1)
		if tick() - startCheck > 0.5 then
			break
		end
	end

	if progressBar.Visible then
		local progressFrame = progressBar:FindFirstChild("Frame")
		local lastSize = progressFrame and progressFrame.Size.X.Scale or 0
		local lastChange = tick()

		repeat
			task.wait(0.1)
			
			if selectedOreBox and selectedOreBox.Color == Color3.new(1, 0.7, 0.3) then
				print("Broken ore, skipping")
				ore:Destroy()
				break
			end

			if PlayerDetectionOn and checkPlayerDistance(ore) < SafetyDistance then
				print("Player too close, stopped mining")
				tpBack()
				break
			end

			if #workspace.Mine:GetChildren() >= BlocksToReset then
				print("Mine resetting, stopped mining")
				break
			end

			if progressFrame then
				local currentSize = progressFrame.Size.X.Scale
				if math.abs(currentSize - lastSize) > 0.001 then
					lastSize = currentSize
					lastChange = tick()
				elseif tick() - lastChange > 10 then
					print("Progress stuck, retrying")
					ore:Destroy() -- delete stuck ore
					break
				end
			end
		until mined or not progressBar.Visible or (not AutoOresOn and not CoordMinerOn)
	end

	if not mined and conn then conn:Disconnect() end
end

-- Ore priorities
local function getOrePriorities()
	local ores = {}
	for oreName in string.gmatch(OreInput.Text, "([^,]+)") do
		oreName = oreName:gsub("^%s+", ""):gsub("%s+$", "")
		table.insert(ores, oreName)
	end
	return ores
end

local function gridToWorld(x, y, z)
	-- Converts block coords to world position
	return Vector3.new(x*6, 5000 - y*6, z*6)
end

-- Count ores
local function countOres(orePriorities)
	local counts = {}
	for _, oreName in ipairs(orePriorities) do
		counts[oreName] = 0
	end
	for _, block in pairs(workspace.Mine:GetChildren()) do
		if counts[block.Name] ~= nil then
			counts[block.Name] += 1
		end
	end
	return counts
end

-- Update ore label
local function updateOreLabel()
	local orePriorities = getOrePriorities()
	local counts = countOres(orePriorities)
	local displayText = ""
	for _, oreName in ipairs(orePriorities) do
		displayText ..= oreName .. ": " .. tostring(counts[oreName]) .. "\n"
	end
	OresLabel.Text = displayText ~= "" and displayText or "No ores selected"
end

local function deleteEntities()
	local char, hrp = getCharacter()
	if not hrp or not char then return end
	
	if workspace:FindFirstChild("Entities") then
		for _, ent in pairs(workspace.Entities:GetChildren()) do
			if ent:FindFirstChild("Torso") then
				if (ent.Torso.Position - hrp.Position).Magnitude <= 100 then
					ent:Destroy()
				end
			end
		end
	end
end

local function collectCoins()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			local coins = v.Items.Mine.Pad.BillboardGui.Amount.Text:gsub("%D", "")
			if tonumber(coins) and tonumber(coins) > CollectThreshold then
				local char, hrp = getCharacter()
				if char and hrp then
					-- Unanchor so touched fires
					hrp.Anchored = false

					-- Teleport slightly inside pad
					hrp.CFrame = v.Items.Mine.Pad.CFrame

					task.wait(0.5) -- give time to register touch

					-- Re-anchor for mining stability
					hrp.Anchored = true
				end
			end
		end
	end
end



local function parseCoords(text)
	if not text or text == "" then return nil end
	text = text:gsub("[,|]", " ")
	local coords = {}
	for num in string.gmatch(text, "-?%d+") do
		table.insert(coords, tonumber(num))
	end
	if #coords < 3 then
		warn("Invalid coord input")
		return nil
	end
	return coords[1], coords[2], coords[3]
end

local function getClosestBlock()
	local char, hrp = getCharacter()
	if not hrp then return nil, nil, nil end
	local pos = hrp.Position
	local x = math.floor(pos.X/6 + 0.5)
	local y = math.floor((5000 - pos.Y)/6 + 0.5)
	local z = math.floor(pos.Z/6 + 0.5)
	return x, y, z
end

-- Returns the next block to mine along cardinal directions
local function getNextBlock(currentX, currentY, currentZ, targetX, targetY, targetZ)
	local dirs = {}
	if currentY ~= targetY then
		table.insert(dirs, Vector3.new(0, (targetY > currentY and -1 or 1) * 6, 0))
	elseif currentX ~= targetX then
		table.insert(dirs, Vector3.new((targetX > currentX and 1 or -1) * 6, 0, 0))
	elseif currentZ ~= targetZ then
		table.insert(dirs, Vector3.new(0, 0, (targetZ > currentZ and 1 or -1) * 6))
	else
		return nil
	end

	local startPos = gridToWorld(currentX, currentY, currentZ)
	for _, dir in ipairs(dirs) do
		local ray = Ray.new(startPos, dir)
		local part, _ = workspace:FindPartOnRayWithWhitelist(ray, {workspace.Mine})
		if part and not part:FindFirstChild("Claimed") then
			return part
		end
	end

	-- Fallback: check all cardinal directions
	local fallbackDirs = {
		Vector3.new(6,0,0), Vector3.new(-6,0,0),
		Vector3.new(0,-6,0), Vector3.new(0,6,0),
		Vector3.new(0,0,6), Vector3.new(0,0,-6)
	}
	for _, dir in ipairs(fallbackDirs) do
		local ray = Ray.new(startPos, dir)
		local part, _ = workspace:FindPartOnRayWithWhitelist(ray, {workspace.Mine})
		if part and not part:FindFirstChild("Claimed") then
			return part
		end
	end

	return nil
end

task.spawn(function()
	while task.wait(0.3) do
		local char, hrp = getCharacter()
		if not hrp then continue end

		-- Mine reset check
		if #workspace.Mine:GetChildren() >= BlocksToReset then
			coordMinerState.active = false
			local start = tick()
			repeat
				task.wait(0.1)
				tpBack()
			until tick() - start >= 45
			continue
		end
		
		local AvailableOres = 0
		-- AutoOres
		if AutoOresOn then
			local orePriorities = getOrePriorities()
			local oresFound = {}
			for _, ore in pairs(workspace.Mine:GetChildren()) do
				if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
					table.insert(oresFound, {ore = ore, priority = table.find(orePriorities, ore.Name)})
				end
			end
			AvailableOres = #oresFound
			table.sort(oresFound, function(a,b)
				if a.priority ~= b.priority then return a.priority < b.priority end
				return a.ore.Position.Y > b.ore.Position.Y
			end)

			for _, entry in ipairs(oresFound) do
				local ore = entry.ore
				if not (ore and ore.Parent) or ore:FindFirstChild("Claimed") then continue end

				local tool = equipPickaxeForOre(ore)
				if not tool then break end

				if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
				safeTeleportToObj(ore)
				deleteEntities()

				workspace.CurrentCamera.SelectedItem.Value = ore
				tool.SetTarget:InvokeServer(ore)
				tool.Activation:FireServer(true)
				waitForOreMined(ore)
				tool.Activation:FireServer(false)
				checkInventory()

				break
			end
		end
		
		-- CoordMiner
		if CoordMinerOn and AvailableOres <= 1 then
			-- Init state
			-- CoordMiner initialization (inside your main loop)
			if not coordMinerState.active then
				local tx, ty, tz = parseCoords(CoordMinerInput.Text)
				if not tx then 
					CoordMinerOn = false
					CoordMinerButton.Text = "OFF"
					CoordMinerInput.TextEditable = true
					local char, hrp = getCharacter()
					if hrp then hrp.Anchored = false end

					coordMinerState = {
						currentX = nil, currentY = nil, currentZ = nil,
						targetX = nil, targetY = nil, targetZ = nil,
						active = false
					}
					continue 
				end

				coordMinerState.targetX = tx
				coordMinerState.targetY = ty
				coordMinerState.targetZ = tz

				-- Find the block closest to the goal
				-- Find the block closest to the goal that is not near any player
				local closestDist = math.huge
				local startBlock
				for _, block in pairs(workspace.Mine:GetChildren()) do
					if block and block.Parent and not block:FindFirstChild("Claimed") and not block:FindFirstChild("PlacedItem") then
						local bx = math.floor(block.Position.X/6 + 0.5)
						local by = math.floor((5000 - block.Position.Y)/6 + 0.5)
						local bz = math.floor(block.Position.Z/6 + 0.5)

						-- Skip blocks too close to a player
						if PlayerDetectionOn and checkPlayerDistance(block) < SafetyDistance then
							continue
						end

						local dist = (Vector3.new(bx, by, bz) - Vector3.new(tx, ty, tz)).Magnitude
						if dist < closestDist then
							closestDist = dist
							startBlock = block
							coordMinerState.currentX = bx
							coordMinerState.currentY = by
							coordMinerState.currentZ = bz
						end
					end
				end

				coordMinerState.active = true

				-- Teleport to closest block to goal if found
				if startBlock and startBlock.Parent then
					safeTeleportToObj(startBlock)
				end
			end

			-- Mine towards goal
			local reached = false
			while CoordMinerOn and not reached do
				local orePriorities = getOrePriorities()
				local oresFound = 0
				for _, ore in pairs(workspace.Mine:GetChildren()) do
					if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
						oresFound += 1
					end
				end
				if AutoOresOn and oresFound > 0 then break end -- pause if ore spawns

				local nextBlock
				repeat
					nextBlock = getNextBlock(
						coordMinerState.currentX, coordMinerState.currentY, coordMinerState.currentZ,
						coordMinerState.targetX, coordMinerState.targetY, coordMinerState.targetZ
					)

					-- Skip blocks that have PlacedItem
					if nextBlock and (nextBlock:FindFirstChild("PlacedItem") or nextBlock:FindFirstChild("Claimed")) then
						-- mark block as "skipped" by temporarily anchoring current coords to it
						local pos = nextBlock.Position
						coordMinerState.currentX = math.floor(pos.X/6 + 0.5)
						coordMinerState.currentY = math.floor((5000 - pos.Y)/6 + 0.5)
						coordMinerState.currentZ = math.floor(pos.Z/6 + 0.5)
						nextBlock = nil  -- force loop to get a new block
					end
				until not (nextBlock and (nextBlock:FindFirstChild("PlacedItem") or nextBlock:FindFirstChild("Claimed")))

				-- Goal reached
				if not nextBlock then
					reached = true
					break
				end

				local tool = equipPickaxeForOre(nextBlock)
				if tool then
					if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
					safeTeleportToObj(nextBlock)
					deleteEntities()

					workspace.CurrentCamera.SelectedItem.Value = nextBlock
					tool.SetTarget:InvokeServer(nextBlock)
					tool.Activation:FireServer(true)
					waitForOreMined(nextBlock)
					tool.Activation:FireServer(false)
					checkInventory()
				end

				-- Update current coordinates
				local pos = nextBlock.Position
				coordMinerState.currentX = math.floor(pos.X/6 + 0.5)
				coordMinerState.currentY = math.floor((5000 - pos.Y)/6 + 0.5)
				coordMinerState.currentZ = math.floor(pos.Z/6 + 0.5)
				task.wait(0.1)
			end

			if reached then
				print("reached")
				CoordMinerOn = false
				CoordMinerButton.Text = "OFF"
				CoordMinerInput.TextEditable = true
				local char, hrp = getCharacter()
				if hrp then
					hrp.Anchored = false
				end

				coordMinerState = {
					currentX = nil,
					currentY = nil,
					currentZ = nil,
					targetX = nil,
					targetY = nil,
					targetZ = nil,
					active = false
				}
			end
		end

		-- Collect coins
		if CollectOn then
			task.wait(0.1)
			collectCoins()
		end
	end
end)

task.spawn(function()
	while task.wait(0.2) do
		if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
			local pos = Player.Character.HumanoidRootPart.Position
			local x, y, z = getBlockCoordinates(pos)
			CoordinatesLabel.Text = "Coords: ("..x..", "..y..", "..z..")"

			PlayerDistanceLabel.Text = "Distance To Player: "..tostring(checkPlayerDistance(Player.Character.HumanoidRootPart))
		else
			CoordinatesLabel.Text = "Coords: N/A"
			PlayerDistanceLabel.Text = "Distance To Player: N/A"
		end
		BlocksInMineLabel.Text = "Blocks Until Reset: "..tostring(BlocksToReset - #workspace.Mine:GetChildren())
		updateOreLabel()
	end
end)

