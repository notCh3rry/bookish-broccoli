print("v28")

spawn(function()
	loadstring(game:HttpGet("https://pastebin.com/raw/6ngxJT8b"))() --freecam lshift+p
	loadstring(game:HttpGet('https://raw.githubusercontent.com/Lucasfin000/SpaceHub/main/UESP'))() --esp
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Player = Players.LocalPlayer

local PlayerDetectionOn = true
local AutoOresOn = false
local CollectOn = false
local CoordMinerOn = false
local Rendering = true
local Fullbright = false
local ExcateLayerOn = false
local platform

local MoveAllItems = ReplicatedStorage:WaitForChild("MoveAllItems")
local BlocksToReset = 115000
local SafetyDistance = 200
local CollectThreshold = 500

local ExcavateLayerLastPos = nil

local coordMinerState = {
	currentX = nil,
	currentY = nil,
	currentZ = nil,
	targetX = nil,
	targetY = nil,
	targetZ = nil,
	active = false
}

game.Workspace:WaitForChild("Players"):WaitForChild("Chryslixm"):WaitForChild("AnomalyRunner"):Destroy()

local function getCharacter()
	-- Wait for character respawn if it's gone
	if not Player.Character then
		Player.CharacterAdded:Wait()
	end

	-- Wait for HRP in the new character
	local char = Player.Character
	local hrp = char:WaitForChild("HumanoidRootPart", 10) -- 10 sec timeout
	return char, hrp
end

-- UI Setup (same as before)
local ScreenGui = Instance.new("ScreenGui", Player:WaitForChild("PlayerGui"))
ScreenGui.Name = "Ooga"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainFrame = Instance.new("Frame", ScreenGui)
MainFrame.Size = UDim2.new(0.157, 0, 0.731, 0)
MainFrame.Position = UDim2.new(0.132, 0, 0.125, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false

local AspectRatio = Instance.new("UIAspectRatioConstraint", MainFrame)
AspectRatio.AspectRatio = 0.316
AspectRatio.AspectType = Enum.AspectType.FitWithinMaxSize
AspectRatio.DominantAxis = Enum.DominantAxis.Width

local OreInput = Instance.new("TextBox", MainFrame)
OreInput.Size = UDim2.new(0.927, 0, 0.163, 0)
OreInput.Position = UDim2.new(0.037, 0, 0.277, 0)
OreInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OreInput.BorderSizePixel = 0
OreInput.Font = Enum.Font.Highway
OreInput.TextScaled = true
OreInput.PlaceholderText = "Ore to Find"
OreInput.Text = ""
OreInput.ClearTextOnFocus = false
OreInput.TextColor3 = Color3.fromRGB(255, 255, 255)

local CoordMinerInput = Instance.new("TextBox", MainFrame)
CoordMinerInput.Size = UDim2.new(0.689, 0, 0.034, 0)
CoordMinerInput.Position = UDim2.new(0.037, 0, 0.232, 0)
CoordMinerInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerInput.BorderSizePixel = 0
CoordMinerInput.Font = Enum.Font.Highway
CoordMinerInput.TextScaled = true
CoordMinerInput.PlaceholderText = "Coords Goal"
CoordMinerInput.Text = ""
CoordMinerInput.ClearTextOnFocus = false
CoordMinerInput.TextColor3 = Color3.fromRGB(255, 255, 255)

-- Player Detection Toggle Button
local PlayerDetectButton = Instance.new("TextButton", MainFrame)
PlayerDetectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDetectButton.Position = UDim2.new(0.032, 0, 0.057, 0)
PlayerDetectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDetectButton.BorderSizePixel = 0
PlayerDetectButton.TextColor3 = Color3.fromRGB(170, 255, 165)
PlayerDetectButton.TextScaled = true
PlayerDetectButton.Font = Enum.Font.Highway
PlayerDetectButton.Text = "Player Detection: ON"
PlayerDetectButton.Activated:Connect(function()
	PlayerDetectionOn = not PlayerDetectionOn
	if PlayerDetectionOn then
		PlayerDetectButton.Text = "Player Detection: ON"
		PlayerDetectButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		PlayerDetectButton.Text = "Player Detection: OFF"
		PlayerDetectButton.TextColor3 = Color3.fromRGB(255, 120, 120)
	end
end)

-- TP Button
local AutoOresButton = Instance.new("TextButton", MainFrame)
AutoOresButton.Size = UDim2.new(0.927, 0, 0.033, 0)
AutoOresButton.Position = UDim2.new(0.037, 0, 0.013, 0)
AutoOresButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
AutoOresButton.BorderSizePixel = 0
AutoOresButton.TextColor3 = Color3.fromRGB(255, 120, 120)
AutoOresButton.TextScaled = true
AutoOresButton.Font = Enum.Font.Highway
AutoOresButton.Text = "Auto Ores: OFF"
AutoOresButton.Activated:Connect(function()
	AutoOresOn = not AutoOresOn
	if AutoOresOn then
		AutoOresButton.Text = "Auto Ores: ON"
		AutoOresButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		AutoOresButton.Text = "Auto Ores: OFF"
		AutoOresButton.TextColor3 = Color3.fromRGB(255, 120, 120)
		Player.Character.HumanoidRootPart.Anchored = false
		
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local CollectButton = Instance.new("TextButton", MainFrame)
CollectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
CollectButton.Position = UDim2.new(0.032, 0, 0.1, 0)
CollectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CollectButton.BorderSizePixel = 0
CollectButton.TextColor3 = Color3.fromRGB(255, 120, 120)
CollectButton.TextScaled = true
CollectButton.Font = Enum.Font.Highway
CollectButton.Text = "Collect Coins: OFF"
CollectButton.Activated:Connect(function()
	CollectOn = not CollectOn
	if CollectOn then
		CollectButton.Text = "Collect Coins: ON"
		CollectButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		CollectButton.Text = "Collect Coins: OFF"
		CollectButton.TextColor3 = Color3.fromRGB(255, 120, 120)
		
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local ExcavateButton = Instance.new("TextButton", MainFrame)
ExcavateButton.Size = UDim2.new(0.927, 0, 0.033, 0)
ExcavateButton.Position = UDim2.new(0.032, 0, 0.144, 0)
ExcavateButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
ExcavateButton.BorderSizePixel = 0
ExcavateButton.TextColor3 = Color3.fromRGB(255, 120, 120)
ExcavateButton.TextScaled = true
ExcavateButton.Font = Enum.Font.Highway
ExcavateButton.Text = "Excavate Layer: OFF"
ExcavateButton.Activated:Connect(function()
	ExcateLayerOn = not ExcateLayerOn
	if ExcateLayerOn then
		ExcavateButton.Text = "Excavate Layer: ON"
		ExcavateButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		ExcavateButton.Text = "Excavate Layer: OFF"
		ExcavateButton.TextColor3 = Color3.fromRGB(255, 120, 120)
		ExcavateLayerLastPos = nil
		
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local CoordMinerButton = Instance.new("TextButton", MainFrame)
CoordMinerButton.Size = UDim2.new(0.197, 0, 0.033, 0)
CoordMinerButton.Position = UDim2.new(0.762, 0, 0.232, 0)
CoordMinerButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerButton.BorderSizePixel = 0
CoordMinerButton.TextColor3 = Color3.fromRGB(255, 120, 120)
CoordMinerButton.TextScaled = true
CoordMinerButton.Font = Enum.Font.Highway
CoordMinerButton.Text = "OFF"
CoordMinerButton.Activated:Connect(function()
	CoordMinerOn = not CoordMinerOn
	if CoordMinerOn then
		CoordMinerButton.Text = "ON"
		CoordMinerInput.TextEditable = false
		CoordMinerButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		CoordMinerButton.Text = "OFF"
		CoordMinerInput.TextEditable = true
		CoordMinerButton.TextColor3 = Color3.fromRGB(255, 120, 120)
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end

		coordMinerState = {
			currentX = nil,
			currentY = nil,
			currentZ = nil,
			targetX = nil,
			targetY = nil,
			targetZ = nil,
			active = false
		}
	end
end)

local RenderingButton = Instance.new("TextButton", MainFrame)
RenderingButton.Size = UDim2.new(0.45, 0, 0.033, 0)
RenderingButton.Position = UDim2.new(0.508, 0, 0.187, 0)
RenderingButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
RenderingButton.BorderSizePixel = 0
RenderingButton.TextColor3 = Color3.fromRGB(170, 255, 165)
RenderingButton.TextScaled = true
RenderingButton.Font = Enum.Font.Highway
RenderingButton.Text = "Rendering: ON"
RenderingButton.Activated:Connect(function()
	Rendering = not Rendering
	if Rendering then
		RenderingButton.Text = "Rendering: ON"
		RenderingButton.TextColor3 = Color3.fromRGB(170, 255, 165)
		RunService:Set3dRenderingEnabled(true)
	else
		RenderingButton.Text = "Rendering: OFF"
		RenderingButton.TextColor3 = Color3.fromRGB(255, 120, 120)
		RunService:Set3dRenderingEnabled(false)
	end
end)

local FullbrightButton = Instance.new("TextButton", MainFrame)
FullbrightButton.Size = UDim2.new(0.45, 0, 0.033, 0)
FullbrightButton.Position = UDim2.new(0.032, 0, 0.187, 0)
FullbrightButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
FullbrightButton.BorderSizePixel = 0
FullbrightButton.TextColor3 = Color3.fromRGB(255, 120, 120)
FullbrightButton.TextScaled = true
FullbrightButton.Font = Enum.Font.Highway
FullbrightButton.Text = "Fullbright: OFF"
FullbrightButton.Activated:Connect(function()
	Fullbright = not Fullbright
	if Fullbright then
		FullbrightButton.Text = "Fullbright: ON"
		FullbrightButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		FullbrightButton.Text = "Fullbright: OFF"
		FullbrightButton.TextColor3 = Color3.fromRGB(255, 120, 120)
	end
end)

local ToggleButton = Instance.new("TextButton", ScreenGui)
ToggleButton.Size = UDim2.new(0, 53, 0, 51)
ToggleButton.Position = UDim2.new(-0.0007, 0, 0.6601, 0)
ToggleButton.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
ToggleButton.BorderSizePixel = 0
ToggleButton.Text = ""
ToggleButton.Activated:Connect(function()
	MainFrame.Visible = not MainFrame.Visible
end)

local OresLabel = Instance.new("TextLabel", MainFrame)
OresLabel.Size = UDim2.new(0.927, 0, 0.354, 0)
OresLabel.Position = UDim2.new(0.037, 0, 0.452, 0)
OresLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OresLabel.BorderSizePixel = 0
OresLabel.Text = ""
OresLabel.TextScaled = true
OresLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
OresLabel.Font = Enum.Font.Highway

local BlocksInMineLabel = Instance.new("TextLabel", MainFrame)
BlocksInMineLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
BlocksInMineLabel.Position = UDim2.new(0.037, 0, 0.818, 0)
BlocksInMineLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
BlocksInMineLabel.BorderSizePixel = 0
BlocksInMineLabel.Text = "Blocks Until Reset: N/A"
BlocksInMineLabel.TextScaled = true
BlocksInMineLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
BlocksInMineLabel.Font = Enum.Font.Highway

local CoordinatesLabel = Instance.new("TextLabel", MainFrame)
CoordinatesLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
CoordinatesLabel.Position = UDim2.new(0.037, 0, 0.861, 0)
CoordinatesLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordinatesLabel.BorderSizePixel = 0
CoordinatesLabel.Text = ""
CoordinatesLabel.TextScaled = true
CoordinatesLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordinatesLabel.Font = Enum.Font.Highway

local PlayerDistanceLabel = Instance.new("TextLabel", MainFrame)
PlayerDistanceLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDistanceLabel.Position = UDim2.new(0.037, 0, 0.905, 0)
PlayerDistanceLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDistanceLabel.BorderSizePixel = 0
PlayerDistanceLabel.Text = ""
PlayerDistanceLabel.TextScaled = true
PlayerDistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerDistanceLabel.Font = Enum.Font.Highway

-- Coordinates calculation (death safe)
local function getBlockCoordinates(position)
	local x = math.floor(position.X / 6)
	local z = math.floor(position.Z / 6)
	local depth = math.floor((5000 - position.Y) / 6)
	if depth < 0 then depth = 0 end
	return x, depth, z
end

local function safeTeleportToPos(pos)
	local char, hrp = getCharacter()
	if not hrp or not char or not pos then return end

	local platformPos = pos - Vector3.new(0, 3, 0)

	if platform and platform.Parent then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "TPPlatform"
	platform.Size = Vector3.new(4, 1, 4)
	platform.CFrame = CFrame.new(platformPos)
	platform.Anchored = true
	platform.CanCollide = true
	platform.Transparency = 1
	platform.Parent = workspace

	-- Teleport player
	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	if char:FindFirstChild("Torso") then char.Torso.CanCollide = false end
	if char:FindFirstChild("Head") then char.Head.CanCollide = false end
	hrp.Anchored = false

	hrp.CFrame = CFrame.new(platformPos + Vector3.new(0, 2, 0))
	task.wait(0.2)

	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	hrp.Anchored = true
end

local function tpBack()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			safeTeleportToPos(v.Spawn.Position)
		end
	end
end

local function equipPickaxeForOre(ore)
	local forge = game.ReplicatedStorage:WaitForChild("Forge")
	local pickaxeName

	if ore.Name == "Dragonstone" or ore.Name == "Boomite" then
		pickaxeName = "Dragonglass" -- Dragonglass pickaxe
	else
		pickaxeName = "Amethyst" -- Default pickaxe
	end

	pcall(function()
		forge:InvokeServer(pickaxeName)
	end)

	local char, hrp = getCharacter()
	
	if not char or not hrp then
		return nil
	end

	local tool = char:FindFirstChild("Pickaxe")
	if not tool then
		repeat
			task.wait()
			tool = char:FindFirstChild("Pickaxe")
		until tool ~= nil or not char or not hrp
	end

	return tool
end


-- Auto-equip Pickaxe on spawn
local function equipPickaxe(char)
	task.spawn(function()
		local backpack = Player:WaitForChild("Backpack")
		local humanoid = char:WaitForChild("Humanoid")
		while humanoid and humanoid.Parent do
			local tool = backpack:FindFirstChild("Pickaxe")
			if tool and not char:FindFirstChild("Pickaxe") then
				humanoid:EquipTool(tool)
			end
			task.wait(1)
		end
	end)
end

if Player.Character then equipPickaxe(Player.Character) end
Player.CharacterAdded:Connect(equipPickaxe)

-- Inventory cleanup
local function checkInventory()
	local ok, err = pcall(function()
		local label = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("Inventory"):WaitForChild("Amount")
		if label and label:IsA("TextLabel") then
			local text = label.Text:gsub("%s+", ""):gsub(",", "")
			local current, max = text:match("^(%d+)/(%d+)$")
			current, max = tonumber(current), tonumber(max)
			if current and max and current >= max then
				MoveAllItems:InvokeServer()
			end
		end
	end)
	if not ok then warn("Empty Inventory Failed: ", err) end
end

local function checkPlayerDistance(object)
	local closestDistance = 999999
	for _, plr in pairs(Players:GetChildren()) do
		if plr ~= Player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			if (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude < closestDistance then
				closestDistance = (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude
			end
		end
	end
	return math.round(closestDistance)
end

local function findNextStone(originPos)
	local directions = 24 -- cast rays in circle
	local radius = 10000 -- scan distance
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {game.Workspace.Mine}
	params.FilterType = Enum.RaycastFilterType.Include

	local bestStone, bestDist

	for i = 1, directions do
		local angle = (2 * math.pi / directions) * i
		local dir = Vector3.new(math.cos(angle), 0, math.sin(angle))
		local result = game.Workspace:Raycast(originPos, dir * radius, params)

		if result and result.Instance and result.Instance.Name == "Stone" then
			local ore = result.Instance
			if not ore:FindFirstChild("Claimed") and ore.Parent == game.Workspace.Mine 
				and (not PlayerDetectionOn or checkPlayerDistance(ore) > SafetyDistance) then
				
				local dist = (ore.Position - originPos).Magnitude
				if not bestStone or dist < bestDist then
					bestStone = ore
					bestDist = dist
				end
			end
		end
	end

	return bestStone
end

-- Wait for ore mined (safe)
local function waitForOreMined(ore)
	if not ore then return end
	local mined = false

	local conn
	conn = ore.AncestryChanged:Connect(function(_, parent)
		if not parent then mined = true conn:Disconnect() end
	end)

	local progressBar
	local selectedOreBox
	pcall(function()
		progressBar = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedItem"):WaitForChild("ProgressBar")
		selectedOreBox = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedOre")
	end)

	local startCheck = tick()
	while progressBar.Visible == false do
		task.wait(0.1)
		if tick() - startCheck > 0.5 then
			break
		end
	end

	if progressBar.Visible then
		local progressFrame = progressBar:FindFirstChild("Frame")
		local lastSize = progressFrame and progressFrame.Size.X.Scale or 0
		local lastChange = tick()

		repeat
			task.wait(0.1)
			
			if selectedOreBox and selectedOreBox.Color == Color3.new(1, 0.7, 0.3) then
				print("Broken ore, skipping")
				ore:Destroy()
				break
			end

			if PlayerDetectionOn and checkPlayerDistance(ore) < SafetyDistance then
				print("Player too close, stopped mining")
				tpBack()
				break
			end

			if #workspace.Mine:GetChildren() >= BlocksToReset then
				print("Mine resetting, stopped mining")
				break
			end

			if progressFrame then
				local currentSize = progressFrame.Size.X.Scale
				if math.abs(currentSize - lastSize) > 0.001 then
					lastSize = currentSize
					lastChange = tick()
				elseif tick() - lastChange > 10 then
					print("Progress stuck, retrying")
					ore:Destroy() -- delete stuck ore
					break
				end
			end
		until mined or not progressBar.Visible or (not AutoOresOn and not CoordMinerOn)
	end

	if not mined and conn then conn:Disconnect() end
end

-- Ore priorities
local function getOrePriorities()
	local ores = {}
	for oreName in string.gmatch(OreInput.Text, "([^,]+)") do
		oreName = oreName:gsub("^%s+", ""):gsub("%s+$", "")
		table.insert(ores, oreName)
	end
	return ores
end

local function gridToWorld(x, y, z)
	-- Converts block coords to world position
	return Vector3.new(x*6, 5000 - y*6, z*6)
end

-- Count ores
local function countOres(orePriorities)
	local counts = {}
	for _, oreName in ipairs(orePriorities) do
		counts[oreName] = 0
	end
	for _, block in pairs(workspace.Mine:GetChildren()) do
		if counts[block.Name] ~= nil then
			counts[block.Name] += 1
		end
	end
	return counts
end

-- Update ore label
local function updateOreLabel()
	local orePriorities = getOrePriorities()
	local counts = countOres(orePriorities)
	local displayText = ""
	for _, oreName in ipairs(orePriorities) do
		displayText ..= oreName .. ": " .. tostring(counts[oreName]) .. "\n"
	end
	OresLabel.Text = displayText ~= "" and displayText or "No ores selected"
end

local function deleteEntities()
	local char, hrp = getCharacter()
	if not hrp or not char then return end
	
	if workspace:FindFirstChild("Entities") then
		for _, ent in pairs(workspace.Entities:GetChildren()) do
			if ent:FindFirstChild("Torso") then
				if (ent.Torso.Position - hrp.Position).Magnitude <= 100 then
					ent:Destroy()
				end
			end
		end
	end
end

local function collectCoins()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			local coins = v.Items.Mine.Pad.BillboardGui.Amount.Text:gsub("%D", "")
			if tonumber(coins) and tonumber(coins) > CollectThreshold then
				task.wait(0.1)
				local char, hrp = getCharacter()
				if char and hrp then
					-- Unanchor so touched fires
					hrp.Anchored = false

					-- Teleport slightly inside pad
					hrp.CFrame = v.Items.Mine.Pad.CFrame

					task.wait(0.5) -- give time to register touch

					-- Re-anchor for mining stability
					hrp.Anchored = true
				end
			end
		end
	end
end

local function getAvailableOreCount()
	local orePriorities = getOrePriorities()
	local oresFound = 0
	for _, ore in pairs(workspace.Mine:GetChildren()) do
		if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
			oresFound += 1
		end
	end
	return oresFound
end

local function parseCoords(text)
	if not text or text == "" then return nil end
	text = text:gsub("[,|]", " ")
	local coords = {}
	for num in string.gmatch(text, "-?%d+") do
		table.insert(coords, tonumber(num))
	end
	if #coords < 3 then
		warn("Invalid coord input")
		return nil
	end
	return coords[1], coords[2], coords[3]
end

local function getNextBlock(currentX, currentY, currentZ, targetX, targetY, targetZ)
	local offsets = {
		Vector3.new( 1,  0,  0),
		Vector3.new(-1,  0,  0),
		Vector3.new( 0,  1,  0),
		Vector3.new( 0, -1,  0),
		Vector3.new( 0,  0,  1),
		Vector3.new( 0,  0, -1),
	}

	local bestBlock, bestDist = nil, math.huge
	local startPos = gridToWorld(currentX, currentY, currentZ)

	for _, offset in ipairs(offsets) do
		local nx, ny, nz = currentX + offset.X, currentY + offset.Y, currentZ + offset.Z
		local neighborPos = gridToWorld(nx, ny, nz)

		-- raycast to neighbor
		local dir = (neighborPos - startPos).Unit * 6
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = {workspace.Mine}

		local result = workspace:Raycast(startPos, dir, params)
		if result and result.Instance then
			local block = result.Instance
			if block.Parent == game.Workspace.Mine
				and not block:FindFirstChild("Claimed")
				and (not PlayerDetectionOn or checkPlayerDistance(block) > SafetyDistance)
			then
				local dist = (Vector3.new(nx, ny, nz) - Vector3.new(targetX, targetY, targetZ)).Magnitude
				if dist < bestDist then
					bestBlock = block
					bestDist = dist
				end
			end
		end
	end

	return bestBlock
end

task.spawn(function()
	while task.wait() do
		local char, hrp = getCharacter()
		if not hrp then continue end

		-- Mine reset check
		if #workspace.Mine:GetChildren() >= BlocksToReset then
			coordMinerState.active = false
			local start = tick()
			repeat
				task.wait(0.1)
				tpBack()
			until tick() - start >= 45
			continue
		end
		
		-- AutoOres
		if AutoOresOn then
			local orePriorities = getOrePriorities()
			local oresFound = {}
			for _, ore in pairs(workspace.Mine:GetChildren()) do
				if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
					table.insert(oresFound, {ore = ore, priority = table.find(orePriorities, ore.Name)})
				end
			end
			table.sort(oresFound, function(a,b)
				if a.priority ~= b.priority then return a.priority < b.priority end
				return a.ore.Position.Y > b.ore.Position.Y
			end)

			for _, entry in ipairs(oresFound) do
				local ore = entry.ore
				if not (ore and ore.Parent) or ore:FindFirstChild("Claimed") then continue end

				local tool = equipPickaxeForOre(ore)
				if not tool then break end

				if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
				safeTeleportToPos(ore.Position)
				deleteEntities()

				workspace.CurrentCamera.SelectedItem.Value = ore
				tool.SetTarget:InvokeServer(ore)
				tool.Activation:FireServer(true)
				waitForOreMined(ore)
				tool.Activation:FireServer(false)

				break
			end
		end
		
		if ExcateLayerOn and getAvailableOreCount() <= 1 then
			if ExcavateLayerLastPos then
				local char, hrp = getCharacter()
				if not char or hrp then continue end
				
				safeTeleportToPos(ExcavateLayerLastPos) 
			end
			
			while ExcateLayerOn do
				if AutoOresOn and getAvailableOreCount() > 0 then break end
				
				local ore = findNextStone(hrp.Position)
				
				if not ore then
					ExcateLayerOn = false
					ExcavateButton.Text = "Excavate Layer: OFF"
					ExcavateButton.TextColor3 = Color3.fromRGB(255, 120, 120)
					ExcavateLayerLastPos = nil
					
					continue
				end
				
				if ore:FindFirstChild("Claimed") then continue end

				local tool = equipPickaxeForOre(ore)
				if not tool then break end

				if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
				safeTeleportToPos(ore.Position)
				deleteEntities()

				workspace.CurrentCamera.SelectedItem.Value = ore
				tool.SetTarget:InvokeServer(ore)
				tool.Activation:FireServer(true)
				waitForOreMined(ore)
				tool.Activation:FireServer(false)
				
				local char, hrp = getCharacter()
				if hrp then
					ExcavateLayerLastPos = hrp.Position
				end
				
				task.wait()
			end
		end
		
		-- CoordMiner
		if CoordMinerOn and getAvailableOreCount() <= 1 then
			-- Init state
			-- CoordMiner initialization (inside your main loop)
			if not coordMinerState.active then
				local tx, ty, tz = parseCoords(CoordMinerInput.Text)
				if not tx then 
					CoordMinerOn = false
					CoordMinerButton.Text = "OFF"
					CoordMinerInput.TextEditable = true
					local char, hrp = getCharacter()
					if hrp then hrp.Anchored = false end

					coordMinerState = {
						currentX = nil, currentY = nil, currentZ = nil,
						targetX = nil, targetY = nil, targetZ = nil,
						active = false
					}
					continue 
				end

				coordMinerState.targetX = tx
				coordMinerState.targetY = ty
				coordMinerState.targetZ = tz

				-- Find the block closest to the goal
				-- Find the block closest to the goal that is not near any player
				local closestDist = math.huge
				local startBlock
				for _, block in pairs(workspace.Mine:GetChildren()) do
					if block and block.Parent and not block:FindFirstChild("Claimed") and not block:FindFirstChild("PlacedItem") then
						local bx = math.floor(block.Position.X/6 + 0.5)
						local by = math.floor((5000 - block.Position.Y)/6 + 0.5)
						local bz = math.floor(block.Position.Z/6 + 0.5)

						-- Skip blocks too close to a player
						if PlayerDetectionOn and checkPlayerDistance(block) < SafetyDistance then
							continue
						end

						local dist = (Vector3.new(bx, by, bz) - Vector3.new(tx, ty, tz)).Magnitude
						if dist < closestDist then
							closestDist = dist
							startBlock = block
							coordMinerState.currentX = bx
							coordMinerState.currentY = by
							coordMinerState.currentZ = bz
						end
					end
				end

				coordMinerState.active = true

				-- Teleport to closest block to goal if found
				if startBlock and startBlock.Parent then
					safeTeleportToPos(startBlock.Position)
				end
			end

			-- Mine towards goal
			local reached = false
			while CoordMinerOn and not reached do
				if AutoOresOn and getAvailableOreCount() > 0 then break end -- pause if ore spawns
				
				if coordMinerState.currentX == coordMinerState.targetX
					and coordMinerState.currentY == coordMinerState.targetY
					and coordMinerState.currentZ == coordMinerState.targetZ then
					reached = true
					break
				end

				local nextBlock = getNextBlock(
					coordMinerState.currentX, coordMinerState.currentY, coordMinerState.currentZ,
					coordMinerState.targetX, coordMinerState.targetY, coordMinerState.targetZ
				)

				-- Goal reached
				if not nextBlock then
					reached = true
					break
				end

				local tool = equipPickaxeForOre(nextBlock)
				if tool then
					if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
					safeTeleportToPos(nextBlock.Position)
					deleteEntities()

					workspace.CurrentCamera.SelectedItem.Value = nextBlock
					tool.SetTarget:InvokeServer(nextBlock)
					tool.Activation:FireServer(true)
					waitForOreMined(nextBlock)
					tool.Activation:FireServer(false)
				end

				-- Update current coordinates
				local pos = nextBlock.Position
				coordMinerState.currentX = math.floor(pos.X/6 + 0.5)
				coordMinerState.currentY = math.floor((5000 - pos.Y)/6 + 0.5)
				coordMinerState.currentZ = math.floor(pos.Z/6 + 0.5)
			end

			if reached then
				CoordMinerOn = false
				CoordMinerButton.Text = "OFF"
				CoordMinerInput.TextEditable = true
				local char, hrp = getCharacter()
				if hrp then
					hrp.Anchored = false
				end

				coordMinerState = {
					currentX = nil,
					currentY = nil,
					currentZ = nil,
					targetX = nil,
					targetY = nil,
					targetZ = nil,
					active = false
				}
			end
		end
		
		checkInventory()
		-- Collect coins
		if CollectOn then
			collectCoins()
		end
	end
end)

task.spawn(function()
	while task.wait(0.2) do
		if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
			local pos = Player.Character.HumanoidRootPart.Position
			local x, y, z = getBlockCoordinates(pos)
			CoordinatesLabel.Text = "Coords: ("..x..", "..y..", "..z..")"

			PlayerDistanceLabel.Text = "Distance To Player: "..tostring(checkPlayerDistance(Player.Character.HumanoidRootPart))
		else
			CoordinatesLabel.Text = "Coords: N/A"
			PlayerDistanceLabel.Text = "Distance To Player: N/A"
		end
		BlocksInMineLabel.Text = "Blocks Until Reset: "..tostring(BlocksToReset - #workspace.Mine:GetChildren())
		updateOreLabel()
	end
end)

