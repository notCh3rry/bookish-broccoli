print("v57")

spawn(function()
	loadstring(game:HttpGet("https://pastebin.com/raw/6ngxJT8b"))() --freecam lshift+p
	loadstring(game:HttpGet('https://raw.githubusercontent.com/Lucasfin000/SpaceHub/main/UESP'))() --esp
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Player = Players.LocalPlayer

local PlayerDetectionOn = true
local AutoOresOn = false
local CollectOn = false
local CoordMinerOn = false
local Rendering = true
local CoriumFarmOn = false
local ExcateLayerOn = false
local KillZombiesOn = false
local platform

local MoveAllItems = ReplicatedStorage:WaitForChild("MoveAllItems")
local BlocksToReset = 115000
local SafetyDistance = 200
local CollectThreshold = 500
local DefaultPickaxe = "Newtonium"

local Admins = {"berezaa", "EvilArtist", "company113", "OutOfOrderFoxy", "jackintheblox", "Yamitsu", "NobleDragon"}

local ExcavateLayerLastPos = nil

local coordMinerState = {
	currentX = nil,
	currentY = nil,
	currentZ = nil,
	targetX = nil,
	targetY = nil,
	targetZ = nil,
	active = false
}

game.Workspace:WaitForChild("Players"):WaitForChild("Chryslixm"):WaitForChild("AnomalyRunner"):Destroy()

local function getCharacter()
	if not Player.Character then
		Player.CharacterAdded:Wait()
	end

	local char = Player.Character
	local hrp = char:WaitForChild("HumanoidRootPart", 10)
	return char, hrp
end

Player.CharacterAdded:Connect(function(char)
	char:WaitForChild("AnomalyRunner"):Destroy()
end)

Players.PlayerAdded:Connect(function(plr)
	if table.find(Admins, plr.Name) then
		Player:Kick("Admin detected")
	end
end)

-- UI Setup (same as before)
local ScreenGui = Instance.new("ScreenGui", Player:WaitForChild("PlayerGui"))
ScreenGui.Name = "Ooga"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainFrame = Instance.new("Frame", ScreenGui)
MainFrame.Size = UDim2.new(0.157, 0, 0.731, 0)
MainFrame.Position = UDim2.new(0.132, 0, 0.125, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false

local AspectRatio = Instance.new("UIAspectRatioConstraint", MainFrame)
AspectRatio.AspectRatio = 0.316
AspectRatio.AspectType = Enum.AspectType.FitWithinMaxSize
AspectRatio.DominantAxis = Enum.DominantAxis.Width

local OreInput = Instance.new("TextBox", MainFrame)
OreInput.Size = UDim2.new(0.927, 0, 0.163, 0)
OreInput.Position = UDim2.new(0.037, 0, 0.321, 0)
OreInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OreInput.BorderSizePixel = 0
OreInput.Font = Enum.Font.Highway
OreInput.TextScaled = true
OreInput.PlaceholderText = "Ore to Find"
OreInput.Text = ""
OreInput.ClearTextOnFocus = false
OreInput.TextColor3 = Color3.fromRGB(255, 255, 255)

local CoordMinerInput = Instance.new("TextBox", MainFrame)
CoordMinerInput.Size = UDim2.new(0.689, 0, 0.034, 0)
CoordMinerInput.Position = UDim2.new(0.037, 0, 0.232, 0)
CoordMinerInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerInput.BorderSizePixel = 0
CoordMinerInput.Font = Enum.Font.Highway
CoordMinerInput.TextScaled = true
CoordMinerInput.PlaceholderText = "Coords Goal"
CoordMinerInput.Text = ""
CoordMinerInput.ClearTextOnFocus = false
CoordMinerInput.TextColor3 = Color3.fromRGB(255, 255, 255)

local ZombieRangeInput = Instance.new("TextBox", MainFrame)
ZombieRangeInput.Size = UDim2.new(0.334, 0, 0.034, 0)
ZombieRangeInput.Position = UDim2.new(0.037, 0, 0.277, 0)
ZombieRangeInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
ZombieRangeInput.BorderSizePixel = 0
ZombieRangeInput.Font = Enum.Font.Highway
ZombieRangeInput.TextScaled = true
ZombieRangeInput.PlaceholderText = "Range"
ZombieRangeInput.Text = ""
ZombieRangeInput.ClearTextOnFocus = false
ZombieRangeInput.TextColor3 = Color3.fromRGB(255, 255, 255)

ZombieRangeInput:GetPropertyChangedSignal("Text"):Connect(function()
	ZombieRangeInput.Text = ZombieRangeInput.Text:gsub('%D+', '');
end)

-- Player Detection Toggle Button
local PlayerDetectButton = Instance.new("TextButton", MainFrame)
PlayerDetectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDetectButton.Position = UDim2.new(0.032, 0, 0.057, 0)
PlayerDetectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDetectButton.BorderSizePixel = 0
PlayerDetectButton.TextColor3 = Color3.fromRGB(170, 255, 165)
PlayerDetectButton.TextScaled = true
PlayerDetectButton.Font = Enum.Font.Highway
PlayerDetectButton.Text = "Player Detection: ON"
PlayerDetectButton.Activated:Connect(function()
	PlayerDetectionOn = not PlayerDetectionOn
	if PlayerDetectionOn then
		PlayerDetectButton.Text = "Player Detection: ON"
		PlayerDetectButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		PlayerDetectButton.Text = "Player Detection: OFF"
		PlayerDetectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	end
end)

-- TP Button
local AutoOresButton = Instance.new("TextButton", MainFrame)
AutoOresButton.Size = UDim2.new(0.927, 0, 0.033, 0)
AutoOresButton.Position = UDim2.new(0.037, 0, 0.013, 0)
AutoOresButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
AutoOresButton.BorderSizePixel = 0
AutoOresButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AutoOresButton.TextScaled = true
AutoOresButton.Font = Enum.Font.Highway
AutoOresButton.Text = "Auto Ores: OFF"
AutoOresButton.Activated:Connect(function()
	AutoOresOn = not AutoOresOn
	if AutoOresOn then
		AutoOresButton.Text = "Auto Ores: ON"
		AutoOresButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		AutoOresButton.Text = "Auto Ores: OFF"
		AutoOresButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		Player.Character.HumanoidRootPart.Anchored = false
		
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local CollectButton = Instance.new("TextButton", MainFrame)
CollectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
CollectButton.Position = UDim2.new(0.032, 0, 0.1, 0)
CollectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CollectButton.BorderSizePixel = 0
CollectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CollectButton.TextScaled = true
CollectButton.Font = Enum.Font.Highway
CollectButton.Text = "Collect Coins: OFF"
CollectButton.Activated:Connect(function()
	CollectOn = not CollectOn
	if CollectOn then
		CollectButton.Text = "Collect Coins: ON"
		CollectButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		CollectButton.Text = "Collect Coins: OFF"
		CollectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local ExcavateButton = Instance.new("TextButton", MainFrame)
ExcavateButton.Size = UDim2.new(0.927, 0, 0.033, 0)
ExcavateButton.Position = UDim2.new(0.032, 0, 0.144, 0)
ExcavateButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
ExcavateButton.BorderSizePixel = 0
ExcavateButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ExcavateButton.TextScaled = true
ExcavateButton.Font = Enum.Font.Highway
ExcavateButton.Text = "Excavate Layer: OFF"
ExcavateButton.Activated:Connect(function()
	ExcateLayerOn = not ExcateLayerOn
	if ExcateLayerOn then
		ExcavateButton.Text = "Excavate Layer: ON"
		ExcavateButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		ExcavateButton.Text = "Excavate Layer: OFF"
		ExcavateButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		ExcavateLayerLastPos = nil
		
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local CoordMinerButton = Instance.new("TextButton", MainFrame)
CoordMinerButton.Size = UDim2.new(0.197, 0, 0.033, 0)
CoordMinerButton.Position = UDim2.new(0.762, 0, 0.232, 0)
CoordMinerButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerButton.BorderSizePixel = 0
CoordMinerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordMinerButton.TextScaled = true
CoordMinerButton.Font = Enum.Font.Highway
CoordMinerButton.Text = "OFF"
CoordMinerButton.Activated:Connect(function()
	CoordMinerOn = not CoordMinerOn
	if CoordMinerOn then
		CoordMinerButton.Text = "ON"
		CoordMinerInput.TextEditable = false
		CoordMinerButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		CoordMinerButton.Text = "OFF"
		CoordMinerInput.TextEditable = true
		CoordMinerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		local char, hrp = getCharacter()
		if hrp then
			hrp.Anchored = false
		end

		coordMinerState = {
			currentX = nil,
			currentY = nil,
			currentZ = nil,
			targetX = nil,
			targetY = nil,
			targetZ = nil,
			active = false
		}
	end
end)

local RenderingButton = Instance.new("TextButton", MainFrame)
RenderingButton.Size = UDim2.new(0.45, 0, 0.033, 0)
RenderingButton.Position = UDim2.new(0.508, 0, 0.187, 0)
RenderingButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
RenderingButton.BorderSizePixel = 0
RenderingButton.TextColor3 = Color3.fromRGB(170, 255, 165)
RenderingButton.TextScaled = true
RenderingButton.Font = Enum.Font.Highway
RenderingButton.Text = "Rendering: ON"
RenderingButton.Activated:Connect(function()
	Rendering = not Rendering
	if Rendering then
		RenderingButton.Text = "Rendering: ON"
		RenderingButton.TextColor3 = Color3.fromRGB(170, 255, 165)
		RunService:Set3dRenderingEnabled(true)
	else
		RenderingButton.Text = "Rendering: OFF"
		RenderingButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		RunService:Set3dRenderingEnabled(false)
	end
end)

local CoriumFarmButton = Instance.new("TextButton", MainFrame)
CoriumFarmButton.Size = UDim2.new(0.45, 0, 0.033, 0)
CoriumFarmButton.Position = UDim2.new(0.032, 0, 0.187, 0)
CoriumFarmButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoriumFarmButton.BorderSizePixel = 0
CoriumFarmButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CoriumFarmButton.TextScaled = true
CoriumFarmButton.Font = Enum.Font.Highway
CoriumFarmButton.Text = "Corium: OFF"
CoriumFarmButton.Activated:Connect(function()
	CoriumFarmOn = not CoriumFarmOn
	if CoriumFarmOn then
		CoriumFarmButton.Text = "Corium: ON"
		CoriumFarmButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		CoriumFarmButton.Text = "Corium: OFF"
		CoriumFarmButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	end
end)

local KillZombiesButton = Instance.new("TextButton", MainFrame)
KillZombiesButton.Size = UDim2.new(0.551, 0, 0.033, 0)
KillZombiesButton.Position = UDim2.new(0.407, 0, 0.277, 0)
KillZombiesButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
KillZombiesButton.BorderSizePixel = 0
KillZombiesButton.TextColor3 = Color3.fromRGB(255, 255, 255)
KillZombiesButton.TextScaled = true
KillZombiesButton.Font = Enum.Font.Highway
KillZombiesButton.Text = "Kill Zombies: OFF"
KillZombiesButton.Activated:Connect(function()
	KillZombiesOn = not KillZombiesOn
	if KillZombiesOn then
		KillZombiesButton.Text = "Kill Zombies: ON"
		KillZombiesButton.TextColor3 = Color3.fromRGB(170, 255, 165)
	else
		KillZombiesButton.Text = "Kill Zombies: OFF"
		KillZombiesButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	end
end)

local ToggleButton = Instance.new("TextButton", ScreenGui)
ToggleButton.Size = UDim2.new(0, 53, 0, 51)
ToggleButton.Position = UDim2.new(-0.0007, 0, 0.6601, 0)
ToggleButton.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
ToggleButton.BorderSizePixel = 0
ToggleButton.Text = ""
ToggleButton.Activated:Connect(function()
	MainFrame.Visible = not MainFrame.Visible
end)

local OresLabel = Instance.new("TextLabel", MainFrame)
OresLabel.Size = UDim2.new(0.927, 0, 0.354, 0)
OresLabel.Position = UDim2.new(0.037, 0, 0.495, 0)
OresLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OresLabel.BorderSizePixel = 0
OresLabel.Text = ""
OresLabel.TextScaled = true
OresLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
OresLabel.Font = Enum.Font.Highway

local BlocksInMineLabel = Instance.new("TextLabel", MainFrame)
BlocksInMineLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
BlocksInMineLabel.Position = UDim2.new(0.037, 0, 0.861, 0)
BlocksInMineLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
BlocksInMineLabel.BorderSizePixel = 0
BlocksInMineLabel.Text = "Blocks Until Reset: N/A"
BlocksInMineLabel.TextScaled = true
BlocksInMineLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
BlocksInMineLabel.Font = Enum.Font.Highway

local CoordinatesLabel = Instance.new("TextLabel", MainFrame)
CoordinatesLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
CoordinatesLabel.Position = UDim2.new(0.037, 0, 0.905, 0)
CoordinatesLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordinatesLabel.BorderSizePixel = 0
CoordinatesLabel.Text = ""
CoordinatesLabel.TextScaled = true
CoordinatesLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordinatesLabel.Font = Enum.Font.Highway

local PlayerDistanceLabel = Instance.new("TextLabel", MainFrame)
PlayerDistanceLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDistanceLabel.Position = UDim2.new(0.037, 0, 0.948, 0)
PlayerDistanceLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDistanceLabel.BorderSizePixel = 0
PlayerDistanceLabel.Text = ""
PlayerDistanceLabel.TextScaled = true
PlayerDistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerDistanceLabel.Font = Enum.Font.Highway

-- Coordinates calculation (death safe)
local function getBlockCoordinates(position)
	local x = math.floor(position.X / 6)
	local z = math.floor(position.Z / 6)
	local depth = math.floor((5000 - position.Y) / 6)
	if depth < 0 then depth = 0 end
	return x, depth, z
end

local function safeTeleportToPos(pos)
	local char, hrp = getCharacter()
	if not hrp or not char or not pos then return end

	local platformPos = pos - Vector3.new(0, 3, 0)

	if platform and platform.Parent then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Name = "TPPlatform"
	platform.Size = Vector3.new(4, 1, 4)
	platform.CFrame = CFrame.new(platformPos)
	platform.Anchored = true
	platform.CanCollide = true
	platform.Transparency = 1
	platform.Parent = workspace

	-- Teleport player
	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	if char:FindFirstChild("Torso") then char.Torso.CanCollide = false end
	if char:FindFirstChild("Head") then char.Head.CanCollide = false end
	hrp.Anchored = false

	hrp.CFrame = CFrame.new(platformPos + Vector3.new(0, 2, 0))
	task.wait(0.2)

	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	hrp.Anchored = true
end

local function tpBack()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			safeTeleportToPos(v.Spawn.Position)
		end
	end
end

local function equipPickaxeForOre(ore)
	local forge = game.ReplicatedStorage:WaitForChild("Forge")
	local pickaxeName = DefaultPickaxe
	
	if ore and ore.Parent then
		if ore.Name == "Dragonstone" or ore.Name == "Boomite" then
			pickaxeName = "Dragonglass" -- Dragonglass pickaxe
		else
			pickaxeName = DefaultPickaxe -- Default pickaxe
		end
	end

	pcall(function()
		forge:InvokeServer(pickaxeName)
	end)

	local char, hrp = getCharacter()
	
	if not char or not hrp then
		return nil
	end

	local tool = char:FindFirstChild("Pickaxe")
	if not tool then
		repeat
			task.wait()
			tool = char:FindFirstChild("Pickaxe")
		until tool ~= nil or not char or not hrp
	end

	return tool
end


-- Auto-equip Pickaxe on spawn
local function equipPickaxe(char)
	task.spawn(function()
		local backpack = Player:WaitForChild("Backpack")
		local humanoid = char:WaitForChild("Humanoid")
		while humanoid and humanoid.Parent do
			local tool = backpack:FindFirstChild("Pickaxe")
			if tool and not char:FindFirstChild("Pickaxe") then
				humanoid:EquipTool(tool)
			end
			task.wait(1)
		end
	end)
end

if Player.Character then equipPickaxe(Player.Character) end
Player.CharacterAdded:Connect(equipPickaxe)

-- Inventory cleanup
local function checkInventory()
	local ok, err = pcall(function()
		local label = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("Inventory"):WaitForChild("Amount")
		if label and label:IsA("TextLabel") then
			local text = label.Text:gsub("%s+", ""):gsub(",", "")
			local current, max = text:match("^(%d+)/(%d+)$")
			current, max = tonumber(current), tonumber(max)
			if current and max and current >= max then
				MoveAllItems:InvokeServer()
			end
		end
	end)
	if not ok then warn("Empty Inventory Failed: ", err) end
end

local function checkPlayerDistance(object)
	local closestDistance = 9999999
	for _, plr in pairs(Players:GetChildren()) do
		if plr ~= Player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			if (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude < closestDistance then
				closestDistance = (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude
			end
		end
	end
	return math.round(closestDistance)
end

local function findNextStone(originPos)
	local directions = 24 -- cast rays in circle
	local radius = 10000 -- scan distance
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {game.Workspace.Mine}
	params.FilterType = Enum.RaycastFilterType.Include

	local bestStone, bestDist

	for i = 1, directions do
		local angle = (2 * math.pi / directions) * i
		local dir = Vector3.new(math.cos(angle), 0, math.sin(angle))
		local result = game.Workspace:Raycast(originPos, dir * radius, params)

		if result and result.Instance and result.Instance.Name == "Stone" then
			local ore = result.Instance
			if not ore:FindFirstChild("Claimed") and ore.Parent == game.Workspace.Mine 
				and (not PlayerDetectionOn or checkPlayerDistance(ore) > SafetyDistance) then
				
				local dist = (ore.Position - originPos).Magnitude
				if not bestStone or dist < bestDist then
					bestStone = ore
					bestDist = dist
				end
			end
		end
	end

	return bestStone
end

-- Wait for ore mined (safe)
local function waitForOreMined(ore)
	if not ore then return end
	local mined = false

	local conn
	conn = ore.AncestryChanged:Connect(function(_, parent)
		if not parent then mined = true conn:Disconnect() end
	end)

	local progressBar
	local selectedOreBox
	pcall(function()
		progressBar = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedItem"):WaitForChild("ProgressBar")
		selectedOreBox = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedOre")
	end)

	local startCheck = tick()
	
	while progressBar.Visible == false and not mined do
		task.wait()
		if tick() - startCheck > 0.5 then
			break
		end
	end
	
	local char, hrp = getCharacter()
	if not char or not hrp then return end

	if progressBar.Visible then
		local progressFrame = progressBar:FindFirstChild("Frame")
		local lastSize = progressFrame and progressFrame.Size.X.Scale or 0
		local lastChange = tick()

		repeat
			task.wait()
			
			if selectedOreBox and selectedOreBox.Color == Color3.new(1, 0.7, 0.3) then
				print("Broken ore, skipping")
				ore:Destroy()
				break
			end

			if PlayerDetectionOn and checkPlayerDistance(ore) < SafetyDistance then
				print("Player too close, stopped mining")
				tpBack()
				break
			end

			if #workspace.Mine:GetChildren() >= BlocksToReset then
				print("Mine resetting, stopped mining")
				break
			end

			if progressFrame then
				local currentSize = progressFrame.Size.X.Scale
				if math.abs(currentSize - lastSize) > 0.001 then
					lastSize = currentSize
					lastChange = tick()
				elseif tick() - lastChange > 10 then
					print("Progress stuck, retrying")
					ore:Destroy() -- delete stuck ore
					break
				end
			end
			
			if not char or not hrp or not char:FindFirstChild("Humanoid") or char:FindFirstChild("Humanoid").Health <= 0 then
				print("Player died, stopped mining")
				break
			end
		until mined or not progressBar.Visible or (not AutoOresOn and not CoordMinerOn and not CoriumFarmOn)
	end

	if not mined and conn then conn:Disconnect() end
end

local function equipSpecific(pickaxeName)
	local forge = game.ReplicatedStorage:WaitForChild("Forge")
	pcall(function()
		forge:InvokeServer(pickaxeName)
	end)

	local char, hrp = getCharacter()
	if not char or not hrp then return nil end

	local tool = char:FindFirstChild("Pickaxe")
	if not tool then
		repeat
			task.wait()
			tool = char:FindFirstChild("Pickaxe")
		until tool ~= nil or not char or not hrp
	end

	return tool
end

-- Ore priorities
local function getOrePriorities()
	local ores = {}
	for oreName in string.gmatch(OreInput.Text, "([^,]+)") do
		oreName = oreName:gsub("^%s+", ""):gsub("%s+$", "")
		table.insert(ores, oreName)
	end
	return ores
end

local function gridToWorld(x, y, z)
	-- Converts block coords to world position
	return Vector3.new(x*6, 5000 - y*6, z*6)
end

-- Count ores
local function countOres(orePriorities)
	local counts = {}
	for _, oreName in ipairs(orePriorities) do
		counts[oreName] = 0
	end
	for _, block in pairs(workspace.Mine:GetChildren()) do
		if counts[block.Name] ~= nil then
			counts[block.Name] += 1
		end
	end
	return counts
end

-- Update ore label
local function updateOreLabel()
	local orePriorities = getOrePriorities()
	local counts = countOres(orePriorities)
	local displayText = ""
	for _, oreName in ipairs(orePriorities) do
		displayText ..= oreName .. ": " .. tostring(counts[oreName]) .. "\n"
	end
	OresLabel.Text = displayText ~= "" and displayText or "No ores selected"
end

local function collectCoins()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			local coins = v.Items.Mine.Pad.BillboardGui.Amount.Text:gsub("%D", "")
			if tonumber(coins) and tonumber(coins) > CollectThreshold then
				task.wait(0.1)
				local char, hrp = getCharacter()
				if char and hrp then
					-- Unanchor so touched fires
					hrp.Anchored = false

					-- Teleport slightly inside pad
					hrp.CFrame = v.Items.Mine.Pad.CFrame

					task.wait(0.5) -- give time to register touch

					-- Re-anchor for mining stability
					hrp.Anchored = true
				end
			end
		end
	end
end

local function killZombies()
	local char, hrp = getCharacter()
	if not char or not hrp then return end

	local range = tonumber(ZombieRangeInput.Text) or 0
	if range <= 0 then return end

	for _, zombie in pairs(workspace.Entities:GetChildren()) do
		if not KillZombiesOn then break end
		if zombie.Name == "Zombie" and zombie:FindFirstChild("Torso") and zombie:FindFirstChild("Humanoid") and zombie:FindFirstChild("Humanoid").Health > 0 then
			local char, hrp = getCharacter()
			if not char or not hrp then return end

			local dist = (zombie.Torso.Position - hrp.Position).Magnitude
			if dist <= range and not (PlayerDetectionOn and checkPlayerDistance(zombie.PrimaryPart) < SafetyDistance) then
				-- equip Newtonium
				local tool = equipSpecific("Newtonium")
				if not tool then return end

				repeat
					task.wait()

					if zombie.PrimaryPart and (PlayerDetectionOn and checkPlayerDistance(zombie.PrimaryPart) < SafetyDistance) then
						tpBack()
						break
					end

					if zombie:FindFirstChild("Torso") then
						local char, hrp = getCharacter()
						if char and hrp then
							hrp.Velocity = Vector3.zero
							hrp.RotVelocity = Vector3.zero
							
							local backPos = zombie.Torso.Position - (zombie.Torso.CFrame.LookVector * 2)
							hrp.CFrame = CFrame.new(backPos) * CFrame.Angles(0, (zombie.Torso.Position - backPos).Unit:Angle(Vector3.new(0,0,-1)), 0)
						end
					end

				until not zombie.Parent or not zombie:FindFirstChild("Humanoid") or zombie.Humanoid.Health <= 0 or not zombie.PrimaryPart
					or not KillZombiesOn or not char or not hrp or not char:FindFirstChild("Humanoid") or char:FindFirstChild("Humanoid").Health <= 0 
					or (PlayerDetectionOn and checkPlayerDistance(zombie.PrimaryPart) < SafetyDistance)
			end
		end
	end
end

local function getAvailableOreCount()
	local orePriorities = getOrePriorities()
	local oresFound = 0
	for _, ore in pairs(workspace.Mine:GetChildren()) do
		if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
			oresFound += 1
		end
	end
	return oresFound
end

local function parseCoords(text)
	if not text or text == "" then return nil end
	text = text:gsub("[,|]", " ")
	local coords = {}
	for num in string.gmatch(text, "-?%d+") do
		table.insert(coords, tonumber(num))
	end
	if #coords < 3 then
		warn("Invalid coord input")
		return nil
	end
	return coords[1], coords[2], coords[3]
end

local function getNextBlock(currentX, currentY, currentZ, targetX, targetY, targetZ)
	local offsets = {
		Vector3.new( 1,  0,  0),
		Vector3.new(-1,  0,  0),
		Vector3.new( 0,  1,  0),
		Vector3.new( 0, -1,  0),
		Vector3.new( 0,  0,  1),
		Vector3.new( 0,  0, -1),
	}

	local bestBlock, bestDist = nil, math.huge
	local startPos = gridToWorld(currentX, currentY, currentZ)

	for _, offset in ipairs(offsets) do
		local nx, ny, nz = currentX + offset.X, currentY + offset.Y, currentZ + offset.Z
		local neighborPos = gridToWorld(nx, ny, nz)

		-- raycast to neighbor
		local dir = (neighborPos - startPos).Unit * 6
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Include
		params.FilterDescendantsInstances = {workspace.Mine}

		local result = workspace:Raycast(startPos, dir, params)
		if result and result.Instance then
			local block = result.Instance
			if block.Parent == game.Workspace.Mine
				and not block:FindFirstChild("Claimed")
				and (not PlayerDetectionOn or checkPlayerDistance(block) > SafetyDistance)
			then
				local dist = (Vector3.new(nx, ny, nz) - Vector3.new(targetX, targetY, targetZ)).Magnitude
				if dist < bestDist then
					bestBlock = block
					bestDist = dist
				end
			end
		end
	end

	return bestBlock
end

local function isNearEntity(pos)
	local char, hrp = getCharacter()
	if not char or not hrp then return end
	
	for _, entity in pairs(game.Workspace.Entities:GetChildren()) do
		if hrp and entity and entity:FindFirstChild("Torso") then
			if (entity:FindFirstChild("Torso").Position - pos).Magnitude <= 100 then
				return true
			end
		end
	end
	
	return false
end

local function getClosestBlockToGoal(tx, ty, tz)
	local closestDist = math.huge
	local startBlock
	for _, block in pairs(workspace.Mine:GetChildren()) do
		if block and block.Parent and block:IsA("BasePart") and not block:FindFirstChild("Claimed") and not block:FindFirstChild("PlacedItem") then
			local bx = math.floor(block.Position.X/6 + 0.5)
			local by = math.floor((5000 - block.Position.Y)/6 + 0.5)
			local bz = math.floor(block.Position.Z/6 + 0.5)

			-- Skip blocks too close to a player
			if PlayerDetectionOn and checkPlayerDistance(block) < SafetyDistance then
				continue
			end

			local dist = (Vector3.new(bx, by, bz) - Vector3.new(tx, ty, tz)).Magnitude
			if dist < closestDist then
				closestDist = dist
				startBlock = block
				coordMinerState.currentX = bx
				coordMinerState.currentY = by
				coordMinerState.currentZ = bz
			end
		end
	end
end

task.spawn(function()
	while task.wait() do
		local char, hrp = getCharacter()
		if not char or not hrp or not char:FindFirstChild("Humanoid") then continue end

		-- Mine reset check
		if #workspace.Mine:GetChildren() >= BlocksToReset then
			coordMinerState.active = false
			local start = tick()
			repeat
				task.wait(0.1)
				tpBack()
			until tick() - start >= 45
			continue
		end
		
		if CoriumFarmOn then
			local char, hrp = getCharacter()
			if not char or not hrp then return end

			local tool = equipSpecific("Boomite")
			if not tool then return end
			if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end

			local mineFolder = workspace.Mine

			-- Collect all Newtonium blocks
			local newtoniums = {}
			for _, block in ipairs(mineFolder:GetDescendants()) do
				if block:IsA("BasePart") and block.Name == "Newtonium" then
					table.insert(newtoniums, block)
				end
			end

			-- Directions to check for adjacent blocks (including diagonals)
			local directions = {
				Vector3.new(1,0,0), Vector3.new(-1,0,0),
				Vector3.new(0,1,0), Vector3.new(0,-1,0),
				Vector3.new(0,0,1), Vector3.new(0,0,-1),
				Vector3.new(1,0,1), Vector3.new(-1,0,1),
				Vector3.new(1,0,-1), Vector3.new(-1,0,-1),
				Vector3.new(1,1,0), Vector3.new(-1,1,0),
				Vector3.new(0,1,1), Vector3.new(0,1,-1),
				Vector3.new(1,-1,0), Vector3.new(-1,-1,0),
				Vector3.new(0,-1,1), Vector3.new(0,-1,-1)
			}

			for _, newtonium in ipairs(newtoniums) do
				if not CoriumFarmOn then break end
				if PlayerDetectionOn and checkPlayerDistance(newtonium) < SafetyDistance then break end
				
				local nearbyBlock = nil

				-- Use raycast to find one nearby block next to Newtonium
				for _, dir in ipairs(directions) do
					local origin = newtonium.Position
					local raycastParams = RaycastParams.new()
					raycastParams.FilterType = Enum.RaycastFilterType.Exclude
					raycastParams.FilterDescendantsInstances = {char} -- Ignore player
					local result = workspace:Raycast(origin, dir * 6, raycastParams) -- 4 studs = 1 block approx

					if result and result.Instance and result.Instance.Name ~= "Newtonium" and result.Instance.Name ~= "Corium" then
						nearbyBlock = result.Instance
						break
					end
				end

				-- If a nearby block is found, teleport and mine it
				if nearbyBlock and nearbyBlock.Parent == game.Workspace.Mine and not nearbyBlock:FindFirstChild("Claimed") then
					local char, hrp = getCharacter()
					if char and hrp and char:FindFirstChild("Humanoid") and char:FindFirstChild("Humanoid").Health > 0 then
						safeTeleportToPos(nearbyBlock.Position)
						if char and hrp and char:FindFirstChild("Humanoid") and char:FindFirstChild("Humanoid").Health > 0 then
							workspace.CurrentCamera.SelectedItem.Value = nearbyBlock
							tool.SetTarget:InvokeServer(nearbyBlock)
							tool.Activation:FireServer(true)
							waitForOreMined(nearbyBlock)
							tool.Activation:FireServer(false)
						end
					end
				end
			end
			
			continue
		end
		
		-- AutoOres
		if AutoOresOn then
			local char, hrp = getCharacter()
			if not char or not hrp then break end
			
			local orePriorities = getOrePriorities()
			local oresFound = {}
			for _, ore in pairs(workspace.Mine:GetChildren()) do
				if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
					table.insert(oresFound, {ore = ore, priority = table.find(orePriorities, ore.Name)})
				end
			end
			table.sort(oresFound, function(a,b)
				if a.priority ~= b.priority then return a.priority < b.priority end
				return a.ore.Position.Y > b.ore.Position.Y
			end)

			for _, entry in ipairs(oresFound) do
				local ore = entry.ore
				if not (ore and ore.Parent) or ore:FindFirstChild("Claimed") then continue end

				local tool = equipPickaxeForOre(ore)
				if not tool then break end

				if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
				if ore.Name == "Corium" then
					safeTeleportToPos(ore.Position - Vector3.new(0, 36, 0))
				else
					if isNearEntity(ore.Position) then
						safeTeleportToPos(ore.Position - Vector3.new(0, 6, 0))
					else
						safeTeleportToPos(ore.Position)
					end
				end
				
				local char, hrp = getCharacter()
				if char and hrp and char:FindFirstChild("Humanoid") and char:FindFirstChild("Humanoid").Health > 0 then
					workspace.CurrentCamera.SelectedItem.Value = ore
					tool.SetTarget:InvokeServer(ore)
					tool.Activation:FireServer(true)
					waitForOreMined(ore)
					tool.Activation:FireServer(false)
				end
				
				break
			end
		end
		
		if ExcateLayerOn and not (AutoOresOn and getAvailableOreCount() > 0) then
			if ExcavateLayerLastPos then
				local char, hrp = getCharacter()
				if not char or hrp then continue end
				
				safeTeleportToPos(ExcavateLayerLastPos) 
			end
			
			while ExcateLayerOn do
				if AutoOresOn and getAvailableOreCount() > 0 then break end
				
				local char, hrp = getCharacter()
				if not char or not hrp then break end
				
				local ore = findNextStone(hrp.Position)
				
				if not ore then
					ExcateLayerOn = false
					ExcavateButton.Text = "Excavate Layer: OFF"
					ExcavateButton.TextColor3 = Color3.fromRGB(255, 255, 255)
					ExcavateLayerLastPos = nil
					
					continue
				end
				
				if ore:FindFirstChild("Claimed") then continue end

				local tool = equipPickaxeForOre(ore)
				if not tool then break end

				if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
				if isNearEntity(ore.Position) then
					safeTeleportToPos(ore.Position - Vector3.new(0, 6, 0))
				else
					safeTeleportToPos(ore.Position)
				end

				workspace.CurrentCamera.SelectedItem.Value = ore
				tool.SetTarget:InvokeServer(ore)
				tool.Activation:FireServer(true)
				waitForOreMined(ore)
				tool.Activation:FireServer(false)
				
				local char, hrp = getCharacter()
				if hrp then
					ExcavateLayerLastPos = hrp.Position
				end
				
				checkInventory()
				if KillZombiesOn then
					killZombies()
				end
				if CollectOn then
					collectCoins()
				end
			end
		end
		
		-- CoordMiner
		if CoordMinerOn and not (AutoOresOn and getAvailableOreCount() > 0) then
			-- Init state
			-- CoordMiner initialization (inside your main loop)
			if not coordMinerState.active then
				local tx, ty, tz = parseCoords(CoordMinerInput.Text)
				if not tx then 
					CoordMinerOn = false
					CoordMinerButton.Text = "OFF"
					CoordMinerInput.TextEditable = true
					local char, hrp = getCharacter()
					if hrp then hrp.Anchored = false end

					coordMinerState = {
						currentX = nil, currentY = nil, currentZ = nil,
						targetX = nil, targetY = nil, targetZ = nil,
						active = false
					}
					continue 
				end

				coordMinerState.targetX = tx
				coordMinerState.targetY = ty
				coordMinerState.targetZ = tz

				-- Find the block closest to the goal
				-- Find the block closest to the goal that is not near any player
				local startBlock = getClosestBlockToGoal(tx, ty, tz)

				coordMinerState.active = true

				-- Teleport to closest block to goal if found
				if startBlock and startBlock.Parent then
					if isNearEntity(startBlock.Position) then
						safeTeleportToPos(startBlock.Position - Vector3.new(0, 6, 0))
					else
						safeTeleportToPos(startBlock.Position)
					end
				end
			end

			-- Mine towards goal
			local reached = false
			while CoordMinerOn and not reached do
				if AutoOresOn and getAvailableOreCount() > 0 then break end -- pause if ore spawns
				
				local char, hrp = getCharacter()
				if not char or not hrp then break end
				
				if coordMinerState.currentX == coordMinerState.targetX
					and coordMinerState.currentY == coordMinerState.targetY
					and coordMinerState.currentZ == coordMinerState.targetZ then
					reached = true
					break
				end

				local nextBlock = getNextBlock(
					coordMinerState.currentX, coordMinerState.currentY, coordMinerState.currentZ,
					coordMinerState.targetX, coordMinerState.targetY, coordMinerState.targetZ
				)

				if not nextBlock then
					repeat
						task.wait()
						nextBlock = getClosestBlockToGoal(coordMinerState.targetX, coordMinerState.targetY, coordMinerState.targetZ)
					until nextBlock and nextBlock.Parent
				end

				local tool = equipPickaxeForOre(nextBlock)
				if tool then
					if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript.Enabled = false end
					if nextBlock and nextBlock.Parent then
						if isNearEntity(nextBlock.Position) then
							safeTeleportToPos(nextBlock.Position - Vector3.new(0, 6, 0))
						else
							safeTeleportToPos(nextBlock.Position)
						end

						workspace.CurrentCamera.SelectedItem.Value = nextBlock
						tool.SetTarget:InvokeServer(nextBlock)
						tool.Activation:FireServer(true)
						waitForOreMined(nextBlock)
						tool.Activation:FireServer(false)
					end
				end

				-- Update current coordinates
				local pos = nextBlock.Position
				coordMinerState.currentX = math.floor(pos.X/6 + 0.5)
				coordMinerState.currentY = math.floor((5000 - pos.Y)/6 + 0.5)
				coordMinerState.currentZ = math.floor(pos.Z/6 + 0.5)
				
				checkInventory()
				if KillZombiesOn then
					killZombies()
				end
				if CollectOn then
					collectCoins()
				end
			end

			if reached then
				CoordMinerOn = false
				CoordMinerButton.Text = "OFF"
				CoordMinerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
				CoordMinerInput.TextEditable = true
				local char, hrp = getCharacter()
				if hrp then
					hrp.Anchored = false
				end

				coordMinerState = {
					currentX = nil,
					currentY = nil,
					currentZ = nil,
					targetX = nil,
					targetY = nil,
					targetZ = nil,
					active = false
				}
			end
		end
		
		checkInventory()
		
		if KillZombiesOn then
			killZombies()
		end
		if CollectOn then
			collectCoins()
		end
	end
end)

task.spawn(function()
	while task.wait(0.2) do
		if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
			local pos = Player.Character.HumanoidRootPart.Position
			local x, y, z = getBlockCoordinates(pos)
			CoordinatesLabel.Text = "Coords: ("..x..", "..y..", "..z..")"

			PlayerDistanceLabel.Text = "Distance To Player: "..tostring(checkPlayerDistance(Player.Character.HumanoidRootPart))
		else
			CoordinatesLabel.Text = "Coords: N/A"
			PlayerDistanceLabel.Text = "Distance To Player: N/A"
		end
		BlocksInMineLabel.Text = "Blocks Until Reset: "..tostring(BlocksToReset - #workspace.Mine:GetChildren())
		updateOreLabel()
	end
end)

