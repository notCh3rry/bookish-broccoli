loadstring(game:HttpGet("https://pastebin.com/raw/6ngxJT8b"))() --freecam lshift+p
loadstring(game:HttpGet('https://raw.githubusercontent.com/Lucasfin000/SpaceHub/main/UESP'))() --esp

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Player = Players.LocalPlayer

local isOpen = false
local PlayerDetectionOn = true
local AutoOresOn = false
local CollectOn = false
local CoordMinerOn = false
local platform

local MoveAllItems = ReplicatedStorage:WaitForChild("MoveAllItems")
local BlocksToReset = 115000
local SafetyDistance = 200
local CollectThreshold = 500

local coordMinerState = {
	currentX = nil,
	currentY = nil,
	currentZ = nil,
	targetX = nil,
	targetY = nil,
	targetZ = nil,
	active = false
}

game.Workspace:WaitForChild("Players"):WaitForChild("Chryslixm"):WaitForChild("AnomalyRunner"):Destroy()

-- UI Setup (same as before)
local ScreenGui = Instance.new("ScreenGui", Player:WaitForChild("PlayerGui"))
ScreenGui.Name = "Ooga"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainFrame = Instance.new("Frame", ScreenGui)
MainFrame.Size = UDim2.new(0.157, 0, 0.731, 0)
MainFrame.Position = UDim2.new(0.132, 0, 0.125, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
MainFrame.BorderSizePixel = 0
MainFrame.Visible = false

local AspectRatio = Instance.new("UIAspectRatioConstraint", MainFrame)
AspectRatio.AspectRatio = 0.316
AspectRatio.AspectType = Enum.AspectType.FitWithinMaxSize
AspectRatio.DominantAxis = Enum.DominantAxis.Width

local OreInput = Instance.new("TextBox", MainFrame)
OreInput.Size = UDim2.new(0.927, 0, 0.163, 0)
OreInput.Position = UDim2.new(0.037, 0, 0.188, 0)
OreInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OreInput.BorderSizePixel = 0
OreInput.Font = Enum.Font.Highway
OreInput.TextScaled = true
OreInput.PlaceholderText = "Ore to Find"
OreInput.Text = ""
OreInput.ClearTextOnFocus = false
OreInput.TextColor3 = Color3.fromRGB(255, 255, 255)

local CoordMinerInput = Instance.new("TextBox", MainFrame)
CoordMinerInput.Size = UDim2.new(0.689, 0, 0.034, 0)
CoordMinerInput.Position = UDim2.new(0.037, 0, 0.143, 0)
CoordMinerInput.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerInput.BorderSizePixel = 0
CoordMinerInput.Font = Enum.Font.Highway
CoordMinerInput.TextScaled = true
CoordMinerInput.PlaceholderText = "Coords Goal"
CoordMinerInput.Text = ""
CoordMinerInput.ClearTextOnFocus = false
CoordMinerInput.TextColor3 = Color3.fromRGB(255, 255, 255)

-- Player Detection Toggle Button
local PlayerDetectButton = Instance.new("TextButton", MainFrame)
PlayerDetectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDetectButton.Position = UDim2.new(0.032, 0, 0.057, 0)
PlayerDetectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDetectButton.BorderSizePixel = 0
PlayerDetectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerDetectButton.TextScaled = true
PlayerDetectButton.Font = Enum.Font.Highway
PlayerDetectButton.Text = "Player Detection: ON"
PlayerDetectButton.Activated:Connect(function()
	PlayerDetectionOn = not PlayerDetectionOn
	if PlayerDetectionOn then
		PlayerDetectButton.Text = "Player Detection: ON"
	else
		PlayerDetectButton.Text = "Player Detection: OFF"
	end
end)

-- TP Button
local AutoOresButton = Instance.new("TextButton", MainFrame)
AutoOresButton.Size = UDim2.new(0.927, 0, 0.033, 0)
AutoOresButton.Position = UDim2.new(0.037, 0, 0.013, 0)
AutoOresButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
AutoOresButton.BorderSizePixel = 0
AutoOresButton.TextColor3 = Color3.fromRGB(255, 255, 255)
AutoOresButton.TextScaled = true
AutoOresButton.Font = Enum.Font.Highway
AutoOresButton.Text = "Auto Ores: OFF"
AutoOresButton.Activated:Connect(function()
	AutoOresOn = not AutoOresOn
	if AutoOresOn then
		AutoOresButton.Text = "Auto Ores: ON"
	else
		AutoOresButton.Text = "Auto Ores: OFF"
		Player.Character.HumanoidRootPart.Anchored = false
	end
end)

local CollectButton = Instance.new("TextButton", MainFrame)
CollectButton.Size = UDim2.new(0.927, 0, 0.033, 0)
CollectButton.Position = UDim2.new(0.032, 0, 0.1, 0)
CollectButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CollectButton.BorderSizePixel = 0
CollectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CollectButton.TextScaled = true
CollectButton.Font = Enum.Font.Highway
CollectButton.Text = "Collect Coins: OFF"
CollectButton.Activated:Connect(function()
	CollectOn = not CollectOn
	if CollectOn then
		CollectButton.Text = "Collect Coins: ON"
	else
		CollectButton.Text = "Collect Coins: OFF"
	end
end)

local CoordMinerButton = Instance.new("TextButton", MainFrame)
CoordMinerButton.Size = UDim2.new(0.197, 0, 0.033, 0)
CoordMinerButton.Position = UDim2.new(0.762, 0, 0.144, 0)
CoordMinerButton.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordMinerButton.BorderSizePixel = 0
CoordMinerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordMinerButton.TextScaled = true
CoordMinerButton.Font = Enum.Font.Highway
CoordMinerButton.Text = "OFF"
CoordMinerButton.Activated:Connect(function()
	CoordMinerOn = not CoordMinerOn
	if CoordMinerOn then
		CoordMinerButton.Text = "ON"
	else
		CoordMinerButton.Text = "OFF"
		Player.Character.HumanoidRootPart.Anchored = false
	end
end)

local ToggleButton = Instance.new("TextButton", ScreenGui)
ToggleButton.Size = UDim2.new(0, 53, 0, 51)
ToggleButton.Position = UDim2.new(-0.0007, 0, 0.6601, 0)
ToggleButton.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
ToggleButton.BorderSizePixel = 0
ToggleButton.Text = ""
ToggleButton.Activated:Connect(function()
	MainFrame.Visible = not MainFrame.Visible
end)

local OresLabel = Instance.new("TextLabel", MainFrame)
OresLabel.Size = UDim2.new(0.927, 0, 0.354, 0)
OresLabel.Position = UDim2.new(0.037, 0, 0.363, 0)
OresLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
OresLabel.BorderSizePixel = 0
OresLabel.Text = ""
OresLabel.TextScaled = true
OresLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
OresLabel.Font = Enum.Font.Highway

local BlocksInMineLabel = Instance.new("TextLabel", MainFrame)
BlocksInMineLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
BlocksInMineLabel.Position = UDim2.new(0.037, 0, 0.729, 0)
BlocksInMineLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
BlocksInMineLabel.BorderSizePixel = 0
BlocksInMineLabel.Text = "Blocks Until Reset: N/A"
BlocksInMineLabel.TextScaled = true
BlocksInMineLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
BlocksInMineLabel.Font = Enum.Font.Highway

local CoordinatesLabel = Instance.new("TextLabel", MainFrame)
CoordinatesLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
CoordinatesLabel.Position = UDim2.new(0.037, 0, 0.772, 0)
CoordinatesLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
CoordinatesLabel.BorderSizePixel = 0
CoordinatesLabel.Text = ""
CoordinatesLabel.TextScaled = true
CoordinatesLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
CoordinatesLabel.Font = Enum.Font.Highway

local PlayerDistanceLabel = Instance.new("TextLabel", MainFrame)
PlayerDistanceLabel.Size = UDim2.new(0.927, 0, 0.033, 0)
PlayerDistanceLabel.Position = UDim2.new(0.037, 0, 0.816, 0)
PlayerDistanceLabel.BackgroundColor3 = Color3.fromRGB(56, 56, 56)
PlayerDistanceLabel.BorderSizePixel = 0
PlayerDistanceLabel.Text = ""
PlayerDistanceLabel.TextScaled = true
PlayerDistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PlayerDistanceLabel.Font = Enum.Font.Highway

-- Coordinates calculation (death safe)
local function getBlockCoordinates(position)
	local x = math.floor(position.X / 6)
	local z = math.floor(position.Z / 6)
	local depth = math.floor((5000 - position.Y) / 6)
	if depth < 0 then depth = 0 end
	return x, depth, z
end

local function getCharacter()
	-- Wait for character respawn if it's gone
	if not Player.Character then
		Player.CharacterAdded:Wait()
	end

	-- Wait for HRP in the new character
	local char = Player.Character
	local hrp = char:WaitForChild("HumanoidRootPart", 10) -- 10 sec timeout
	return char, hrp
end

-- Auto-equip Pickaxe on spawn
local function equipPickaxe(char)
	task.spawn(function()
		local backpack = Player:WaitForChild("Backpack")
		local humanoid = char:WaitForChild("Humanoid")
		while humanoid and humanoid.Parent do
			local tool = backpack:FindFirstChild("Pickaxe")
			if tool and not char:FindFirstChild("Pickaxe") then
				humanoid:EquipTool(tool)
			end
			task.wait(1)
		end
	end)
end

if Player.Character then equipPickaxe(Player.Character) end
Player.CharacterAdded:Connect(equipPickaxe)

-- Inventory cleanup
local function checkInventory()
	local ok, err = pcall(function()
		local label = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("Inventory"):WaitForChild("Amount")
		if label and label:IsA("TextLabel") then
			local text = label.Text:gsub("%s+", ""):gsub(",", "")
			local current, max = text:match("^(%d+)/(%d+)$")
			current, max = tonumber(current), tonumber(max)
			if current and max and current >= max then
				MoveAllItems:InvokeServer()
			end
		end
	end)
	if not ok then warn("Empty Inventory Failed: ", err) end
end

local function checkPlayerDistance(object)
	local closestDistance = 999999
	for _, plr in pairs(Players:GetChildren()) do
		if plr ~= Player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			if (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude < closestDistance then
				closestDistance = (object.Position - plr.Character.HumanoidRootPart.Position).Magnitude
			end
		end
	end
	return math.round(closestDistance)
end

local function tpBack()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then

			local char, hrp = getCharacter()
			if char and hrp then
				-- Unanchor so touched fires
				hrp.Anchored = false

				hrp.CFrame = v.Spawn.CFrame

				task.wait(0.2)

				hrp.Anchored = true
			end
		end
	end
end

-- Wait for ore mined (safe)
local function waitForOreMined(ore)
	if not ore then return end
	local mined = false

	local conn
	conn = ore.AncestryChanged:Connect(function(_, parent)
		if not parent then mined = true conn:Disconnect() end
	end)

	local progressBar
	local selectedOreBox
	pcall(function()
		progressBar = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedItem"):WaitForChild("ProgressBar")
		selectedOreBox = Player.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("SelectedOre")
	end)

	local startCheck = tick()
	while progressBar.Visible == false do
		task.wait(0.1)
		if tick() - startCheck > 0.5 then
			break
		end
	end

	if progressBar.Visible then
		local progressFrame = progressBar:FindFirstChild("Frame")
		local lastSize = progressFrame and progressFrame.Size.X.Scale or 0
		local lastChange = tick()

		repeat
			task.wait(0.1)
			
			if selectedOreBox and selectedOreBox.Color == Color3.new(1, 0.7, 0.3) then
				print("Broken ore, skipping")
				ore:Destroy()
				break
			end

			if PlayerDetectionOn and checkPlayerDistance(ore) < SafetyDistance then
				print("Player too close, skipping ore")
				tpBack()
				break
			end

			if #workspace.Mine:GetChildren() >= BlocksToReset then
				print("Mine resetting, stopped mining")
				break
			end

			if progressFrame then
				local currentSize = progressFrame.Size.X.Scale
				if math.abs(currentSize - lastSize) > 0.001 then
					lastSize = currentSize
					lastChange = tick()
				elseif tick() - lastChange > 10 then
					print("Progress stuck, skipping ore")
					ore:Destroy() -- delete stuck ore
					break
				end
			end
		until mined or not progressBar.Visible
	end

	if not mined and conn then conn:Disconnect() end
end

-- Ore priorities
local function getOrePriorities()
	local ores = {}
	for oreName in string.gmatch(OreInput.Text, "([^,]+)") do
		oreName = oreName:gsub("^%s+", ""):gsub("%s+$", "")
		table.insert(ores, oreName)
	end
	return ores
end

-- Count ores
local function countOres(orePriorities)
	local counts = {}
	for _, oreName in ipairs(orePriorities) do
		counts[oreName] = 0
	end
	for _, block in pairs(workspace.Mine:GetChildren()) do
		if counts[block.Name] ~= nil then
			counts[block.Name] += 1
		end
	end
	return counts
end

-- Update ore label
local function updateOreLabel()
	local orePriorities = getOrePriorities()
	local counts = countOres(orePriorities)
	local displayText = ""
	for _, oreName in ipairs(orePriorities) do
		displayText ..= oreName .. ": " .. tostring(counts[oreName]) .. "\n"
	end
	OresLabel.Text = displayText ~= "" and displayText or "No ores selected"
end

-- Coordinates updater (safe)
task.spawn(function()
	while task.wait(0.2) do
		if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
			local pos = Player.Character.HumanoidRootPart.Position
			local x, y, z = getBlockCoordinates(pos)
			CoordinatesLabel.Text = "Coords: ("..x..", "..y..", "..z..")"
			
			PlayerDistanceLabel.Text = "Distance To Player: "..tostring(checkPlayerDistance(Player.Character.HumanoidRootPart))
		else
			CoordinatesLabel.Text = "Coords: N/A"
			PlayerDistanceLabel.Text = "Distance To Player: N/A"
		end
		BlocksInMineLabel.Text = "Blocks Until Reset: "..tostring(BlocksToReset - #workspace.Mine:GetChildren())
		updateOreLabel()
	end
end)

-- Teleport safely with velocity reset
local function safeTeleportToOre(ore)
	local char, hrp = getCharacter()
	if not hrp or not char then return end

	-- Detect nearby entities
	local nearbyEntities = {}
	if workspace:FindFirstChild("Entities") then
		for _, ent in pairs(workspace.Entities:GetChildren()) do
			if ent:FindFirstChild("Torso") then
				if (ent.Torso.Position - ore.Position).Magnitude <= 100 then
					table.insert(nearbyEntities, ent)
				end
			end
		end
	end

	local platformPosition = ore.Position - Vector3.new(0, 3, 0) -- default
	local ignoreList = {ore}

	if #nearbyEntities > 0 then
		-- Ray directions
		local directions = {
			Vector3.new(0, -200, 0), -- down
			Vector3.new(0, 200, 0),  -- up
			Vector3.new(6, 0, 0), Vector3.new(-6, 0, 0), -- left/right
			Vector3.new(0, 0, 6), Vector3.new(0, 0, -6)  -- forward/back
		}

		local hits = {}
		for _, dir in ipairs(directions) do
			local ray = Ray.new(ore.Position, dir)
			local hitPart, hitPos = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
			table.insert(hits, {dir = dir, hitPart = hitPart})
		end

		-- Determine cave orientation
		local hitDown = hits[1].hitPart ~= nil
		local hitUp = hits[2].hitPart ~= nil

		if hitDown and not hitUp then
			-- Ore is on cave floor -> teleport under the block
			platformPosition = ore.Position - Vector3.new(0, 3, 0)
			print("under")
		elseif hitUp and not hitDown then
			-- Ore is on cave ceiling -> teleport above the block
			platformPosition = ore.Position + Vector3.new(0, 3, 0)
			print("over")
		elseif hitDown and hitUp then
			-- Ore is inside a cave -> choose middle above floor
			platformPosition = ore.Position - Vector3.new(0, 3, 0)
			print("middle under")
		end
	end

	-- Place platform before teleport
	if platform and platform.Parent then platform:Destroy() end
	platform = Instance.new("Part")
	platform.Size = Vector3.new(4, 1, 4)
	platform.Position = platformPosition
	platform.Anchored = true
	platform.CanCollide = true
	platform.Transparency = 1
	platform.Parent = workspace

	-- Reset physics
	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	char.Torso.CanCollide = false
	char.Head.CanCollide = false
	hrp.Anchored = false

	-- Teleport player to platform
	hrp.CFrame = CFrame.new(platformPosition + Vector3.new(0, 2, 0)) -- slightly above platform
	task.wait(0.2)

	-- Ensure physics reset
	hrp.Velocity = Vector3.zero
	hrp.RotVelocity = Vector3.zero
	hrp.Anchored = true
end


local function collectCoins()
	for _, v in pairs(game.Workspace.Tycoons:GetChildren()) do
		if v.Owner.Value == Player then
			local coins = v.Items.Mine.Pad.BillboardGui.Amount.Text:gsub("%D", "")
			if tonumber(coins) and tonumber(coins) > CollectThreshold then
				local char, hrp = getCharacter()
				if char and hrp then
					-- Unanchor so touched fires
					hrp.Anchored = false

					-- Teleport slightly inside pad
					hrp.CFrame = v.Items.Mine.Pad.CFrame

					task.wait(0.5) -- give time to register touch

					-- Re-anchor for mining stability
					hrp.Anchored = true
				end
			end
		end
	end
end

local function parseCoords(text)
	if not text or text == "" then return nil end
	text = text:gsub("[,|]", " ")
	local coords = {}
	for num in string.gmatch(text, "-?%d+") do
		table.insert(coords, tonumber(num))
	end
	if #coords < 3 then
		warn("Invalid coord input")
		return nil
	end
	return coords[1], coords[2], coords[3]
end

local function gridToWorld(x, y, z)
	-- Converts block coords to world position
	return Vector3.new(x*6, 5000 - y*6, z*6)
end

local function getClosestBlock()
	local char, hrp = getCharacter()
	if not hrp then return nil, nil, nil end
	local pos = hrp.Position
	local x = math.floor(pos.X/6 + 0.5)
	local y = math.floor((5000 - pos.Y)/6 + 0.5)
	local z = math.floor(pos.Z/6 + 0.5)
	return x, y, z
end

-- Returns the next block to mine along cardinal directions
local function getNextBlock(currentX, currentY, currentZ, targetX, targetY, targetZ)
	local dirs = {}
	if currentY ~= targetY then
		table.insert(dirs, Vector3.new(0, (targetY > currentY and -1 or 1) * 6, 0))
	elseif currentX ~= targetX then
		table.insert(dirs, Vector3.new((targetX > currentX and 1 or -1) * 6, 0, 0))
	elseif currentZ ~= targetZ then
		table.insert(dirs, Vector3.new(0, 0, (targetZ > currentZ and 1 or -1) * 6))
	else
		return nil
	end

	local startPos = gridToWorld(currentX, currentY, currentZ)
	for _, dir in ipairs(dirs) do
		local ray = Ray.new(startPos, dir)
		local part, _ = workspace:FindPartOnRayWithWhitelist(ray, {workspace.Mine})
		if part and not part:FindFirstChild("Claimed") then
			return part
		end
	end

	-- Fallback: check all cardinal directions
	local fallbackDirs = {
		Vector3.new(6,0,0), Vector3.new(-6,0,0),
		Vector3.new(0,-6,0), Vector3.new(0,6,0),
		Vector3.new(0,0,6), Vector3.new(0,0,-6)
	}
	for _, dir in ipairs(fallbackDirs) do
		local ray = Ray.new(startPos, dir)
		local part, _ = workspace:FindPartOnRayWithWhitelist(ray, {workspace.Mine})
		if part and not part:FindFirstChild("Claimed") then
			return part
		end
	end

	return nil
end

task.spawn(function()
	while task.wait(0.3) do
		local char, hrp = getCharacter()
		if not hrp then continue end

		-- Mine reset check
		if #workspace.Mine:GetChildren() >= BlocksToReset then
			coordMinerState.active = false
			tpBack()
			continue
		end

		-- AutoOres
		local minedOreThisCycle = false
		if AutoOresOn then
			local orePriorities = getOrePriorities()
			local oresFound = {}
			for _, ore in pairs(workspace.Mine:GetChildren()) do
				if table.find(orePriorities, ore.Name) and checkPlayerDistance(ore) > SafetyDistance then
					table.insert(oresFound, {ore = ore, priority = table.find(orePriorities, ore.Name)})
				end
			end
			table.sort(oresFound, function(a,b)
				if a.priority ~= b.priority then return a.priority < b.priority end
				return a.ore.Position.Y > b.ore.Position.Y
			end)

			for _, entry in ipairs(oresFound) do
				local ore = entry.ore
				if not (ore and ore.Parent) or ore:FindFirstChild("Claimed") then continue end

				local tool = char:FindFirstChild("Pickaxe") or Player.Backpack:FindFirstChild("Pickaxe")
				if not tool then break end

				if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript:Destroy() end
				safeTeleportToOre(ore)

				workspace.CurrentCamera.SelectedItem.Value = ore
				tool.SetTarget:InvokeServer(ore)
				tool.Activation:FireServer(true)
				waitForOreMined(ore)
				tool.Activation:FireServer(false)
				checkInventory()

				minedOreThisCycle = true
				break
			end
		end

		-- CoordMiner
		if CoordMinerOn and not minedOreThisCycle then
			-- Init state
			if not coordMinerState.active then
				local tx, ty, tz = parseCoords(CoordMinerInput.Text)
				if not tx then CoordMinerOn = false CoordMinerButton.Text = "OFF" continue end
				coordMinerState.targetX = tx
				coordMinerState.targetY = ty
				coordMinerState.targetZ = tz

				local cx, cy, cz = getClosestBlock()
				coordMinerState.currentX = cx
				coordMinerState.currentY = cy
				coordMinerState.currentZ = cz
				coordMinerState.active = true
			end

			-- Mine towards goal
			local reached = false
			while CoordMinerOn and not reached do
				if AutoOresOn then break end -- pause if ore spawns

				local nextBlock = getNextBlock(coordMinerState.currentX, coordMinerState.currentY, coordMinerState.currentZ,
					coordMinerState.targetX, coordMinerState.targetY, coordMinerState.targetZ)

				-- Goal reached
				if not nextBlock then
					reached = true
					break
				end

				local tool = char:FindFirstChild("Pickaxe") or Player.Backpack:FindFirstChild("Pickaxe")
				if tool then
					if tool:FindFirstChild("PickaxeScript") then tool.PickaxeScript:Destroy() end
					safeTeleportToOre(nextBlock)

					workspace.CurrentCamera.SelectedItem.Value = nextBlock
					tool.SetTarget:InvokeServer(nextBlock)
					tool.Activation:FireServer(true)
					waitForOreMined(nextBlock)
					tool.Activation:FireServer(false)
					checkInventory()
				end

				-- Update current coordinates
				local pos = nextBlock.Position
				coordMinerState.currentX = math.floor(pos.X/6 + 0.5)
				coordMinerState.currentY = math.floor((5000 - pos.Y)/6 + 0.5)
				coordMinerState.currentZ = math.floor(pos.Z/6 + 0.5)
				task.wait(0.1)
			end

			if reached then
				CoordMinerOn = false
				CoordMinerButton.Text = "OFF"
				coordMinerState.active = false
			end
		end

		-- Collect coins
		if CollectOn then
			task.wait(0.5)
			collectCoins()
		end
	end
end)
